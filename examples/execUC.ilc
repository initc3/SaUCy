{- UC experiment -}

{- Static corruptions: Either P is corrupted, Q is corrupted, or neither are
   corrupted. -}
data SttCrupt = SttCrupt (String, String) Crupt

data Crupt = CruptP | CruptQ | CruptNone

{- If P is corrupted, then Z shouldn't be able to write to P, messages from F
are forwarded to A, and messages from A are forwarded to F. Otherwise, spawn P
as normal. -}
let wrapper p crupt toZ frZ toF frF toA frA k bits =
  let! crupt' = crupt in
  let! toZ' = toZ in  
    if crupt' then
        print "Crupted" ;
        loop frZ !(lam _ . error "fail")
      |> fwd frF toA
      |> fwd frA toF
    else
      print "Not crupted" ;
      p toZ frZ toF frF k bits

{- The dummy adversary forwards messages between Z and F (and vice versa). -}
{- TODO: Using unpacked write channel should not type check -}
let dummyAdversary crupt toZ frZ toF frF toP frP toQ frQ k bits =
  let! crupt' = crupt in
    fwd frZ toF
  |> fwd frF toZ
  |> fwd frP toZ
  |> fwd frQ toZ

{- The dummy party forwards messages between Z and F (and vice versa). Flipped
argument order for type inference w/o annotations. Fix later. -}
let dummyParty toZ frZ toF frF k bits =
      fwd frZ toF
    |> fwd frF toZ

let fDummy crupt toP frP toQ frQ toA frA k bits =
  let! crupt' = crupt in
      fwd frP toP
    |> fwd frQ toQ
    |> fwd frA toA    

let testEnv toExec frP toP frQ toQ frA toA k bits =
  let! toExec' = toExec in
  let! toP' = toP in
  let! toQ' = toQ in
  let! toA' = toA in
    wr (SttCrupt ("sid1","") CruptP) -> toExec'
    |> loop frP !(lam x . print ("P sent: " ++ x))
    |> loop frQ !(lam x . print ("Q sent: " ++ x))
    |> loop frA !(lam x . print ("A sent: " ++ x) ; print "Env output 1")

{- UC communication layout
   Z --- P/Q
   |  X  |
   A --- F
 -}

let execUC z p q f a k r =
  {- Standard channels -}
  nu (rZ2P, wZ2P), (rP2Z, wP2Z)
  , (rZ2Q, wZ2Q), (rQ2Z, wQ2Z)
  , (rP2F, wP2F), (rF2P, wF2P)
  , (rQ2F, wQ2F), (rF2Q, wF2Q)
  , (rF2A, wF2A), (rA2F, wA2F)
  , (rA2Z, wA2Z), (rZ2A, wZ2A)
  {- Party wrapper channels -}
  , (rP2A, wP2A), (rA2P, wA2P)
  , (rQ2A, wQ2A), (rA2Q, wA2Q)
  {- Z to execution channels -}
  , (rZ2E, wZ2E)
  . print "Initialized" ;
    let! r' = r in
    let (rf,ra,rp,rq,rz) = splitBits5 r' in
      (let (msg, rZ2E) = rd rZ2E in
       let! (SttCrupt sid crupt) = msg in 
	  f !crupt !wF2P rP2F !wF2Q rQ2F !wF2A rA2F k !rf
	|> a !crupt !wA2Z rZ2A !wA2F rF2A !wA2P rP2A !wA2Q rQ2A k !ra
	|> wrapper p !(crupt == CruptP) !wP2Z rZ2P !wP2F rF2P !wP2A rA2P k !rp
	|> wrapper q !(crupt == CruptQ) !wQ2Z rZ2Q !wQ2F rF2Q !wQ2A rA2Q k !rq)
    |> z !wZ2E rP2Z !wZ2P rQ2Z !wZ2Q rA2Z !wZ2A k !rz

let testBits = ![S,Z,Z,S,S,Z,Z,S,S,Z,Z,S,S,Z,Z,S]

let testExec () =
  execUC testEnv
         dummyParty
	 dummyParty
	 fDummy
	 dummyAdversary
	 !()
	 testBits
