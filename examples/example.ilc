{- UC experiment -}

{- Static corruptions: Either P is corrupted, Q is corrupted, or neither are
   corrupted. -}
data Crupt = CruptP | CruptQ | CruptNone

data ZSMsg = GetCRS
           | PublicStrings [Bit] [Bit] [Bit]
	   | ZSCommit [Bit]
	   | ZSOpened [Bit]
	   | ZSOpen' Int [Bit]

data Msg = Commit Int
         | Open
	 | Opened Int
	 | Receipt

data Z2A = A2F a | A2P a | X2Z a

{- If P is corrupted, then Z shouldn't be able to write to P, messages from F
are forwarded to A, and messages from A are forwarded to F. Otherwise, spawn P
as normal. -}
let wrapper p crupt toZ frZ toF frF toA frA toP frP k bits =
  let! crupt' = crupt in
  let! toZ' = toZ in
  let! toF' = toF in
  let! toP' = toP in  
    if crupt' then
        print "Crupted" ;
        loop frZ !(lam _ . error "fail")
      |> fwd frF toA
      |> fwd frA toF
      |> fwd frP toA
    else
      print "Not crupted" ;
      p toZ frZ toF frF toP frP k bits

{- The dummy adversary forwards messages between Z and F (and vice versa). -}
{- TODO: Using unpacked write channel should not type check -}
let dummyAdversary crupt toZ frZ toF frF toP frP toQ frQ toQasP toPasQ k bits =
  let! crupt' = crupt in
  let! toZ' = toZ in
  let! toF' = toF in
  let! toP' = toP in
  let! toQ' = toQ in
  let! toPasQ' = toPasQ in
  let! toQasP' = toQasP in      
    loop frZ !(lam x . match x with
                     | A2F m => wr m -> toF'
		     | A2P m => if crupt' == CruptP
		       	        then wr m -> toQasP'
				else wr m -> toP')
  |> loop frF !(lam x . wr (X2Z x) -> toZ')
  |> loop frP !(lam x . wr (X2Z x) -> toZ')
  |> loop frQ !(lam x . wr (X2Z x) -> toZ')

let simulator crupt toZ frZ toF frF toP frP toQ frQ toQasP toPasQ k bits =
  let! crupt' = crupt in
  let! toF' = toF in
  let! toP' = toP in
  let! toQ' = toQ in    
  let! toZ' = toZ in
  let! k' = k in
  let! bits' = bits in
  let r = ref bits' in
  let (pk0,td0) = kgen 4 in
  let (pk1,td1) = kgen 4 in  
  let r0 = sample 4 r in
  let r1 = sample 4 r in
  let sigma = xors (prg pk0 r0) (prg pk1 r1) in
  let b = ref Nothing in
  if crupt' == CruptP then
    let (_, frZ) = rd frZ in
      wr (X2Z (PublicStrings sigma pk0 pk1)) -> toZ' ;
    let (msg, frZ) = rd frZ in
    let! (A2P mm) = msg in
    let (ZSCommit y) = mm in    
      if (check td0 pk0 y == S) then
        (wr (Commit 0) -> toP' ; (let b := Just 0))
      else
        if (check td1 pk1 (xors y sigma) == S) then
	  (wr (Commit 1) -> toF' ; (let b := Just 1))
	else
	  {- y is invalid -}
          (wr (Commit 0) -> toP' ; (let b := Just 0)) ;
    let (_, frZ) = rd frZ in
      wr Open -> toP'
  else
    let (_, frZ) = rd frZ in
      wr (X2Z (PublicStrings sigma pk0 pk1)) -> toZ' ;  
    let (msg, frQ) = rd frQ in
    let! msg' = msg in
    let y = prg pk0 r0 in
      wr (X2Z (ZSCommit y)) -> toZ' ;
    let (msg'', frQ) = rd frQ in
    let! (Opened b') = msg'' in
      if (b' == 0) then
        wr (X2Z (ZSOpened r0)) -> toZ'
      else
        wr (X2Z (ZSOpened r1)) -> toZ'

{--------------------Parties--------------------}
{- The dummy party forwards messages between Z and F (and vice versa). Flipped
argument order for type inference w/o annotations. Fix later. -}
let dummyParty toZ frZ toF frF toP frP k bits =
      fwd frZ toF
    |> fwd frF toZ

let pParty toZ frZ toF frF toQ frQ k bits =
  let! toZ' = toZ in
  let! bits' = bits in
  let (msg, frZ)= rd frZ in
  let! (Commit b) = msg in
    wr GetCRS -> toF ;
    let (msg', frF) = rd frF in
    let! (PublicStrings sigma pk0 pk1) = msg' in
    let r = take 4 bits' in 
    let x = if b == 0 then prg pk0 r else xors (prg pk0 r) sigma in
      wr ZSCommit x -> toQ ;
      let (msg'', frZ)= rd frZ in
        wr (ZSOpen' b r) -> toQ
      
let qParty toZ frZ toF frF toP frP k bits =
  let! toZ' = toZ in
  let! bits' = bits in
  let (msg, frP) = rd frP in
  let! (ZSCommit x) = msg in
    wr GetCRS -> toF ;
    let (msg', frF) = rd frF in
    let! (PublicStrings sigma pk0 pk1) = msg' in
      wr Receipt -> toZ' ;
      let (msg'', frP) = rd frP in
      let! (ZSOpen' b r) = msg'' in
        if b == 0 && x == prg pk0 r || b == 1 && x == xors (prg pk1 r) sigma
        then wr (Opened b) -> toZ'
        else wr (Opened b) -> toZ'
	{- TODO: -}
	{-else error "Cannot occur in honest case"-}
      
let committer toZ frZ toF frF k bits =
  let! bits' = bits in
  {- Should receive b from Z and public parameters from Fcrs? -}
  let b = 0 in
  let sigma = [S,Z,S,Z] in
  let pk0 = [S,Z,S,Z] in
  let pk1 = [S,Z,S,Z] in  
  let r = [Z,Z,Z,Z] in 
  let x = if b == 0 then prg pk0 r else xors (prg pk1 r) sigma in
      fwd frZ toF
    |> fwd frF toZ

{--------------------Functionalities--------------------}

{- One-time commitment functionality -}
let fCom crupt toP frP toQ frQ toA frA k bits =
  let! crupt' = crupt in
  let! toP' = toP in
  let! toQ' = toQ in
  let! toA' = toA in
  let! bits' = bits in
  let (msg, frP) = rd frP in
  let! (Commit b) = msg in
    wr Receipt -> toQ' ;
    let (msg', frP) = rd frP in
    let! Open = msg' in
      wr (Opened b) -> toQ'

{- fCrs_helper :: Ref (Maybe Bitstring) -> Wr Bitstring -> a ->@W Unit -}
let fCrs_helper d c x = match (@d) with
    		      	{- Fix bug here -}
                        | Nothing => (let d := Just (PublicStrings [Z,S] [Z,S] [Z,S])) ;
			             wr (PublicStrings [Z,S] [Z,S] [Z,S]) -> c
	                | Just d' => wr d' -> c

{- Parameterize with distribution? -}
let fCrs crupt toP frP toQ frQ toA frA k bits =
  let! crupt' = crupt in
  let! toP' = toP in
  let! toQ' = toQ in
  let! toA' = toA in
  let! bits' = bits in
  let d = ref Nothing in
      loop frP !(fCrs_helper d toP')
    |> loop frQ !(fCrs_helper d toQ')
    |> loop frA !(fCrs_helper d toA')

let fDummy crupt toP frP toQ frQ toA frA k bits =
  let! crupt' = crupt in
      fwd frP toP
    |> fwd frQ toQ
    |> fwd frA toA

{--------------------Environments--------------------}
let envCruptNone toP frP toQ frQ toA frA k bits =
  let! toP' = toP in
  let! toQ' = toQ in
  let! toA' = toA in
    wr (Commit 0) -> toP' ;
    let (x, frQ) = rd frQ in
      print "Z:" ; print x ; wr Open -> toP' ;
    {- TODO: Fix -}
    let (x2, frQ) = rd frQ in
      print "Z:" ; print x2

let envCruptP toP frP toQ frQ toA frA k bits =
  let! toP' = toP in
  let! toQ' = toQ in
  let! toA' = toA in
    wr (A2F GetCRS) -> toA' ;
    let (msg,frA) = rd frA in
    let! (X2Z (PublicStrings sigma pk0 pk1)) = msg in
    let y = [Z,S,S,Z] in
      wr (A2P (ZSCommit y)) -> toA' ;
    let (msg',frQ) = rd frQ in
      wr (A2P (ZSOpen' 0 y)) -> toA' ;
    let (msg'',frQ) = rd frQ in
      print msg''

let envCruptQ toP frP toQ frQ toA frA k bits  =
  let! toP' = toP in
  let! toQ' = toQ in
  let! toA' = toA in
    wr (A2F GetCRS) -> toA' ;
    let (msg,frA) = rd frA in
    let! (X2Z mm) = msg in
    let PublicStrings sigma pk0 pk1 = mm in
      wr (Commit 0) -> toP' ;
    let (msg',frA) = rd frA in
      wr Open -> toP' ;
    let (msg'',frA) = rd frA in
      print "output bit"

let testEnv toP frP toQ frQ toA frA k bits =
  let! toP' = toP in
  let! toQ' = toQ in
  let! toA' = toA in
      loop frP !(lam x . print "P sent")
    |> loop frQ !(lam x . print "Q sent")
    |> loop frA !(lam x . print "A sent")
      
{- UC communication layout
   Z --- P/Q
   |  X  |
   A --- F
 -}

let execUC z p q f a k r crupt =
  {- Standard channels -}
  nu (rZ2P, wZ2P), (rP2Z, wP2Z)
  , (rZ2Q, wZ2Q), (rQ2Z, wQ2Z)
  , (rP2F, wP2F), (rF2P, wF2P)
  , (rQ2F, wQ2F), (rF2Q, wF2Q)
  , (rF2A, wF2A), (rA2F, wA2F)
  , (rA2Z, wA2Z), (rZ2A, wZ2A)
  {- Party wrapper channels -}
  , (rP2A, wP2A), (rA2P, wA2P)
  , (rQ2A, wQ2A), (rA2Q, wA2Q)
  , (rP2Q, wP2Q), (rQ2P, wQ2P)  
  . print "Initialized" ;
    let! r' = r in
    let! crupt' = crupt in    
    let (rf,ra,rp,rq,rz) = splitBits5 r' in
	 (f crupt !wF2P rP2F !wF2Q rQ2F !wF2A rA2F k !rf
	|> a crupt !wA2Z rZ2A !wA2F rF2A !wA2P rP2A !wA2Q rQ2A !wP2Q !wQ2P k !ra
	|> wrapper p !(crupt' == CruptP) !wP2Z rZ2P !wP2F rF2P !wP2A rA2P !wP2Q rQ2P k !rp
	|> wrapper q !(crupt' == CruptQ) !wQ2Z rZ2Q !wQ2F rF2Q !wQ2A rA2Q !wQ2P rP2Q k !rq)
    |> z !wZ2P rP2Z !wZ2Q rQ2Z !wZ2A rA2Z k !rz

let testBits = ![S,Z,Z,S,S,Z,Z,S,S,Z,Z,S,S,Z,Z,S]

let idealCruptNone () =
  execUC envCruptNone
         dummyParty
	 dummyParty
	 fCom
	 simulator
	 !()
	 testBits
	 !CruptNone

let idealCruptP () =
  execUC envCruptP
         dummyParty
	 dummyParty
	 fCom
	 simulator
	 !()
	 testBits
	 !CruptP

let idealCruptQ () =
  execUC envCruptQ
         dummyParty
	 dummyParty
	 fCom
	 simulator
	 !()
	 testBits
	 !CruptQ

let realCruptNone () =
  execUC envCruptNone
  	 pParty
	 qParty
	 fCrs
	 dummyAdversary
	 !()
	 testBits
	 !CruptNone

let realCruptP () =
  execUC envCruptP
  	 pParty
	 qParty
	 fCrs
	 dummyAdversary
	 !()
	 testBits
	 !CruptP

let realCruptQ () =
  execUC envCruptQ
  	 pParty
	 qParty
	 fCrs
	 dummyAdversary
	 !()
	 testBits
	 !CruptQ
