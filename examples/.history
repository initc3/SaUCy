execUC ()
:load Fcom.ilc 
execUC ()
execUC ()
execUC ()
execUC ()
execUC ()
execUC ()
execUC ()
execUC ()
execUC ()
execUC ()
:load Fcom.ilc 
execUC ()
:load Fcom.ilc 
execUC ()
:load Fcom.ilc 
execUC ()
:load Fcom.ilc 
execUC ()
:load Fcom.ilc 
execUC ()
:load Fcom.ilc 
execUC ()
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:browse 
:load Fcom.ilc 
:load Fcom.ilc 
:browse 
:load Fcom.ilc 
:load Fcom.ilc 
:type fcom 
:load Fcom.ilc 
:load Fcom.ilc 
:load 
:load Fcom.ilc 
:load F
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:type Fcom 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load 
:load Fcom.ilc 
:type Fcom 
:load Fcom.ilc 
:type Fcom 
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
clear
ls
:load Fcom.ilc 
:load Fcom.ilc 
:load Fcom.ilc 
:load F-com.ilc 
:type loop
:browse 
:load prelude.ilc 
:browse 
:load prelude.ilc 
let head lst = match lst with | [] => error "wtf" | x:xs => xs
ls
    | (k, v):rest when x == k => v
    | []                      => error "lookup: not in list"
    match assoc with
letrec lookup x assoc =
letrec map f lst = match lst with | [] => [] | x:xs => (f x) : map f xs
:load  prelude.ilc 
:load prelude.ilc 
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
GetBit 1
