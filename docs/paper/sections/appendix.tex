\appendix

\section{Algorithmic Type Checking}
\label{sec:algo-type-check}

Figure~\ref{fig:alg-type-check} gives the algorithmic type checking rules.

\begin{figure*}
\centering
\judgbox{\Delta_{in} ; \Gamma_1 |- e : \Delta_{out}; \Gamma_2; A}{~~Under $\Delta_{in}$ and
  $\Gamma_1$, expression~$e$ results $\Delta_{out}$ and $\Gamma_2$ and has intuitionistic type $A$.}
\begin{mathpar}
\Infer{a-var}
{\Gamma(x) = A}
{\Delta; \Gamma |- x : \Delta; \Gamma; A}
%
\and
%
\Infer{a-unit}
{ }
{\Delta ; \Gamma |- \eUnit : \Delta; \Gamma; \tyUnit}
%
\and
%
\Infer{a-pair}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A_1\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; A_2}
{\Delta_1; \Gamma |- \ePair{e_1}{e_2} : \Delta_3; \Gamma;  \tyProd{A_1}{A_2}}
%
\and
%
\Infer{a-inj}
{i \in \{1, 2\}\\\\
\Delta_1; \Gamma |- e : \Delta_2; \Gamma; A_i}
{\Delta_1 ; \Gamma |- \eInj{i}{e} : \Delta_2; \Gamma; \tySum{A_1}{A_2}}
%
\and
%
\Infer{a-ref}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; A}
{\Delta_1; \Gamma |- \eRef{e} : \Delta_2; \Gamma; \tyRef{A}}
%
\and
%
\Infer{a-split}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyProd{A_1}{A_2}\\\\
\Delta_2; \Gamma,x_1:A_1, x_2: A_2 |- e : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eSplit{e_1}{x_1}{x_2}{e_2} : \Delta_3; \Gamma; B}
%
\and
%  
\Infer{a-case}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; \tySum{A_1}{A_2}\\\\
\Delta_2; \Gamma,x_1:A_1 |- e_1 : \Delta_3; \Gamma; B\\\\
\Delta_2; \Gamma,x_2:A_2 |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eCase{e}{x_1}{e_1}{x_2}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-get}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; \tyRef{A}}
{\Delta_1; \Gamma |- \eGet{e} : \Delta_2; \Gamma; A}
%
\and
%
\Infer{a-set}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyRef{A}\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; A}      
{\Delta_1; \Gamma |- \eSet{e_1}{e_2} : \Delta_3; \Gamma; \tyUnit}
%
\and
%
\Infer{a-fix}
{\emptyctxt; \Gamma,x : \tyArr{A}{\footnotesize m}{A} |- e : \emptyctxt; \Gamma; \tyArr{A}{\footnotesize m}{A}}
{\Delta; \Gamma |- \eFix{x}{e} : \Delta; \Gamma; \tyArr{A}{\footnotesize m}{A}}
%
\and
%
\Infer{a-let}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma, x:A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLet{x}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-let!}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma, x:A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLetBang{x}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-abs}
{\emptyctxt ; \Gamma, x:A |- e : \emptyctxt; \Gamma; B}
{\Delta ; \Gamma |- \eLam{x}{e} : \Delta; \Gamma; \tyArr{A}{\footnotesize m}{B}}
%
\and
%
\Infer{a-app}
{\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_1 : \Delta_3; \Gamma; \tyArr{A}{\footnotesize m}{B}}
{\Delta_1; \Gamma |- \eApp{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-nu}
{\Delta_1, x_1: \tyRd{A} ; \Gamma, x_2 : \tyWr{A} |- e : \Delta_2; \Gamma; B}
{\Delta_1; \Gamma |- \eNu{(x_1, x_2)}{e} : \Delta_2; \Gamma; B}
%
\and
%
\Infer{a-wr}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; \tyWr{A}}
{\Delta_1; \Gamma|- \eWr{e_1}{e_2} : \Delta_3; \Gamma; \tyUnit}
%
\and
%
\Infer{a-letrd}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyRd{A}\\\\
\Delta_2, x_2 : \tyRd{A} ; \Gamma, x_1 : A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLetRd{x_1}{x_2}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-fork}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eFork{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-choice}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; A}
{\Delta_1; \Gamma |- \eChoice{e_1}{e_2} : \Delta_2; \Gamma; A}
\end{mathpar}

\judgbox{\Delta_{in} ; \Gamma_1 |- e : \Delta_{out}; \Gamma_2; A}{~~Under $\Delta_{in}$ and
  $\Gamma_1$, expression~$e$ results $\Delta_{out}$ and $\Gamma_2$ and has affine type $A$.}
\begin{mathpar}
\Infer{a-avar}
{\Delta(x) = X}
{\Delta; \Gamma |- x : \Delta ; \Gamma; X}
%
\and
%
\Infer{a-bang}
{\emptyctxt ; \Gamma |- e : \emptyctxt ; \Gamma ; A}
{\Delta ; \Gamma |- \eBang{e} : \Delta ; \Gamma ; \tyBang{A}}
%
\and
%
\Infer{a-tensor}
{\Delta_1; \Gamma |- e_1 : \Delta_2 ; \Gamma ; X_1\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3 ; \Gamma ; X_2}
{\Delta_1, \Delta_2; \Gamma |- \eLPair{e_1}{e_2} : \Delta_3 ; \Gamma ; \tyTensor{X_1}{X_2}}
%
\and
%  
\Infer{a-asplit}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyTensor{X_1}{X_2}\\\\
\Delta_2,x_1:X_1, x_2: X_2; \Gamma |- e : \Delta_3; \Gamma; Y}
{\Delta_1; \Gamma |- \eLsplit{e_1}{x_1}{x_2}{e_2} : \Delta_3; \Gamma; Y}
%
\and
%
\Infer{a-afix}
{\Delta_1, x : \tyLolli{X}{\footnotesize m}{X}; \Gamma |- e : \Delta_ 2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{X}}
{\Delta_1; \Gamma |- \eLfix{x}{e} : \Delta_2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{X}}
%
\and
\Infer{a-lolli}
{\Delta_1,x:X ; \Gamma |- e : \Delta_2 ; \Gamma ; Y}
{\Delta_1 ; \Gamma |- \eLAM{x}{e} : \Delta_2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{Y}}
%
\and
%
\Infer{a-aapp}
{\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; X\\\\
\Delta_2; \Gamma |- e_1 : \Delta_3; \Gamma; \tyLolli{X}{\footnotesize m}{Y}}
{\Delta_1; \Gamma |- \eLapp{e_1}{e_2} : \Delta_3; \Gamma; Y}
\end{mathpar}
\caption{Algorithmic typing rules.}
\label{fig:alg-type-check}
\end{figure*}

\section{\textsf{execUC}}
\label{sec:full-execUC}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/suc.ilc}
\caption{Full definition of \textsf{execUC}. The channels follow a uniform
naming scheme. The read end of a channel is prefixed with \textsf{r-} and the
write end of a channel is prefixed with \textsf{w-}. The channel \textsf{rZ2P}
denotes the read end of communications from the environment \textsf{z} to the
party \textsf{p}. First, the random bitstring is split amongst each of the five
parties. Then, the functionality, the adversary, and both protocol parties are
spawned in a child process (given the appropriate channels and parameters), and
the process continues as the environment process. Notice that parties are run in
wrapper functions, which alter their behavior depending on whether or not they
are corrupted. If a party is corrupted, then the adversary masquerades as the
party. The mode carried over the rightmost lollipop is $m \in \{(\mathsf{m}_{\mathsf{f}},\mathsf{m}_{\mathsf{a}},\mathsf{m_{\mathsf{z}}) \mid \mathsf{m}_{\mathsf{f}}
|| (\mathsf{m}_{\mathsf{a}} || (\mathsf{R} || (\mathsf{R}
|| \mathsf{m}_{\mathsf{z}}))) => \mathsf{m}_{\mathsf{e}}}\}$.}
\label{fig:execUC}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/dummy.ilc}
\caption{Dummy adversary. The dummy adversary forwards messages from the
environment to either the functionality (if the message has
constructor \textsf{A2F}) or the party \textsf{p} (if the message has
constructor \textsf{A2P}). Similarly, the dummy adversary forwards messages from
the functionality or the procotol parties to the environment.}
\label{fig:dummy-adversary}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/dummyp.ilc}
\caption{Dummy party. The dummy party simply relays information between the
environment and the functionality.}
\label{fig:dummy-party}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/Fcrs.ilc}
\caption{Ideal functionality for common reference string (CRS). \todo{keygen?}}
\label{fig:f-crs}
\end{figure*}

%\begin{figure*}
%\lstinputlisting[style=myilc]{listings/committer.ilc}
%\caption{Universally composable commitment committer.}
%\label{fig:committer}
%\end{figure*}
%
%\begin{figure*}
%\lstinputlisting[style=myilc]{listings/receiver.ilc}
%\caption{Universally composable commitment receiver.}
%\label{fig:receiver}
%\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/sim.ilc}
\caption{Simulator for UC commitment.}
\label{fig:sim}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/simR.ilc}
\caption{Simulator for UC commitment.}
\label{fig:simR}
\end{figure*}

\section{Cryptography Definitions}

\begin{comment}
\subsection{Brain Dump}

\begin{definition}[Protocol Emulation]
Let $\pi$ and $\phi$ be probabilistic polynomial time (p.p.t) protocols. We say
that $\pi$ UC-emulates $\phi$ if for any p.p.t. adversary $\mc{A}$ there exists a
p.p.t. ideal-process adversary $\mc{S}$ such that for any balanced PPT environment
$\mc{Z}$ we have:
\begin{equation*}
\textsc{Exec}_{\phi, \mc{S}, \mc{Z}} \approx \textsc{Exec}_{\pi, \mc{A}, \mc{Z}}.
\end{equation*}
\end{definition}

\begin{lemma}[Protocol Emulation w.r.t. the Dummy Adversary]
Let $\pi$ and $\phi$ be probabilistic polynomial time (p.p.t) protocols. We say
that $\pi$ UC-emulates $\phi$ if for the dummy adversary $\mc{D}$ there exists a
p.p.t. ideal-process adversary $\mc{S}$ such that for any balanced PPT environment
$\mc{Z}$ we have:
\begin{equation*}
\textsc{Exec}_{\phi, \mc{S}, \mc{Z}} \approx \textsc{Exec}_{\pi, \mc{D}, \mc{Z}}.
\end{equation*}
\end{lemma}

\begin{theorem}[Universal Composition]
  Let $\rho$, $\pi$, and $\phi$, be p.p.t protocols such that $\pi$ UC-emulates $\phi$ and
  both $\phi$ and $\pi$ are subroutine respecting. Then protocol $\rho^{\phi -> \pi}$
  UC-emulates protocol $\rho$.
\end{theorem}

\begin{corollary}
  Let $\rho$, $\pi$ be p.p.t protocols such that $\pi$ UC-realizes a p.p.t ideal
  functionality $\mc{F}$, and both $\rho$ and $\pi$ are subroutine respecting. Then
  protocol $\rho^{\pi/\mc{F}}$ UC-emulates protocol $\rho$.
\end{corollary}

\begin{corollary}[Universal Composition: Realizing Functionalities]
  Let $\mc{F}$, $\mc{G}$ be ideal functionalities such that $\mc{F}$ is
  p.p.t. Let $\rho$ be a subroutine respecting protocol that UC-realizes $\mc{G}$,
  and let $\pi$ be a subroutine respecting protocol that UC-realizes
  $\mc{F}$. Then the composed protocol $\rho^{\pi/\mc{F}}$ securely realizes $\mc{G}$.
\end{corollary}

\begin{theorem}
  Protocol $\Pi_{\textsc{com}}$ securely realizes functionality
  $\Func_{\textsc{com}}$ in the CRS model.
\end{theorem}

Let {\sf Bit} be the type of single bits (i.e., 0 or 1), and let {\sf Inf} be
the type of infinite bitstrings. The meaning of an ILC term $\tau$ is given by the
denotation $[\![\tau]\!]\sigma$, which returns, for an infinite bitstring $\sigma{:}{\sf Inf}$, a value
$v{:}{\sf Bit}$. The denotation $[\![\tau]\!]$, then, returns a binary
distribution $d$ over the types of return values for all infinite
bitstrings. Let $\Delta(d_1, d_2)$ denote the statistical distance between two
distributions $d_1$ and $d_2$.
%\[ \Delta(d_1, d_2) \defeq max_{A}|d_1 A - d_2 A|\]

\begin{definition}[$\epsilon$-indistinguishability of ILC Terms]
Let $\tau_1$ and $\tau_2$ be ILC terms, which are closed except for an infinite
bitstream free variable $\sigma{:}{\sf Inf}$. Additionally, for any such $\sigma$,
$[\![t_1]\!]\sigma{:}{\sf Bit}$ and $[\![\tau_2]\!]\sigma{:}{\sf Bit}$. We say that $\tau_1$ and
$\tau_2$ are $\epsilon$-indistinguishable iff $\Delta([\![\tau_1]\!], [\![\tau_2]\!]) \leq \epsilon$.
\end{definition}

\begin{definition}[Probability Distribution Ensemble]
An \emph{ensemble} of probability distributions is a family of probability
distributions $\{ X_{\lambda, z} \}_{\lambda \in \mathbb{N}, z \in {\{0,1\}}^{*}}$ with index
set $\mathbb{N} \times \{0,1\}^{*}$.  The ensembles considered in this work are binary probability
distribution ensembles, which describe single bit outputs of computations, where
$\lambda \in \mathbb{N}$ represents the security parameter, and $z \in \{0,1\}^{*}$
represents input.
\end{definition}

\begin{definition}[Indistinguishability]
Let $X$ and $Y$ be two binary probability distribution
ensembles. We say that $X$ and $Y$ are indistinguishable
(written $X \approx Y$) if for any $c, d \in \mathbb{N}$, there exists
$\lambda_0 \in \mathbb{N}$ such that for all $\lambda > \lambda_0$ and all $z \in \cup_{\lambda \leq \lambda^d}\{0,1\}^{\lambda}$,
\[ | \Pr[X_{\lambda, z} = 1] - \Pr[Y_{\lambda, z} = 1] | < \lambda^{-c}. \]
\end{definition}

\begin{definition}[Bit Producing ILC Term]
Let $\tau$ be an ILC term. We say that $\tau$ is bit producing if it is closed except
for an infinite bitstream free variable $\sigma{:}{\sf Inf}$ and $\sigma{:}{\sf Inf} \vdash
\tau{:}{\sf Bit}$.
%security parameter in judgement
%and converging
\end{definition}

\noindent The denotation $[\![\tau]\!]\sigma$, in which a particular $\sigma$ is
given, evaluates to a value of type {\sf Bit}, and the denotation $[\![\tau]\!]$,
in which no $\sigma$ is specified, evaluates to a binary probability distribution
ensemble over types or values?

\begin{definition}[Indistinguishability of Bit Producing ILC Terms]
Let $\tau_1$ and $\tau_2$ be bit producing ILC terms. We say that $\tau_1$ and $\tau_2$ are
indistinguishable terms if the binary probability distribution ensembles
$[\![\tau_1]\!]$ and $[\![\tau_2]\!]$ are indistinguishable.
\end{definition}
%tau is an ILC+ stream w/ infinite streams and security parameter

\begin{definition}[Protocol Emulation in ILC]
Let $(\pi_1, \mc{F}_1)$ and $(\pi_2, \mc{F}_2)$ be two protocol-functionality
pairs. We say that $(\pi_1, \mc{F}_1)$ UC-emulates $(\pi_2, \mc{F}_2)$ iff for all
adversaries $\mc{A}$, there exists an ideal-process adversary $\mc{S}$ such that
for any environment $\mc{Z}$,
$\textsc{ExecUC}_{\mc{Z}, \mc{A}, \pi_1, \mc{F}_1}$ and
$\textsc{ExecUC}_{\mc{Z}, \mc{S}, \pi_2, \mc{F}_2}$ are bit producing and
indistinguishable terms.
% ExecUC should have sigma and parameter as free variables
% bit respecting adversaries and environments
% first define constraints pi and F for divergence wrt A and Z
\end{definition}

\begin{definition}[Protocol Emulation in ILC]
Let $\pi$ and $\phi$ be probabilistic polynomial time (p.p.t.) protocols. We say that
$\pi$ UC-emulates $\phi$ if for any p.p.t. adversary 
$\mc{A}$, there exists a p.p.t. ideal-process adversary $\mc{S}$
such that for any balanced p.p.t. environment $\mc{Z}$,
$\textsc{ExecUC}_{\phi, \mc{S}, \mc{Z}}$ and $\textsc{ExecUC}_{\pi, \mc{A}, \mc{Z}}$
are indistinguishable bit producing terms.
\end{definition}

\begin{definition}[Protocol Emulation in ILC]
Let $\pi$ and $\phi$ be protocols. We say that $\pi$ UC-emulates $\phi$ iff for all
adversaries $\mc{A}$, there exists an ideal-process adversary $\mc{S}$ such that
for any environment $\mc{Z}$,
$\textsc{ExecUC}[\pi, \mc{A}, \mc{Z}, \lambda, \sigma]$ and
$\textsc{ExecUC}[\phi, \mc{S}, \mc{Z}, \lambda, \sigma]$ are bit producing and
indistinguishable terms.
\end{definition}

\begin{definition}[Balanced Environment]
An environment $\mc{Z}$ is balanced if the overall length of inputs given by
$\mc{Z}$ to the parties of the main instance $\pi$ is at most $k$ times the length
of the input to the adversary.
\end{definition}

Environment should activate the adversary to allow sending of messages.
\end{comment}



\begin{definition}[Interactive Turing Machine]
\end{definition}

\begin{definition}[Trapdoor Permutations~\cite{lindell2014introduction}]
  A tuple of polynomial-time algorithms $(\mathsf{Gen}, \mathsf{Samp},
  f, \textsf{Inv})$ is a family of trapdoor permutations if:
  \begin{itemize}[leftmargin=*]
    \item The probabilistic parameter-generation algorithm \textsf{Gen}, on
  input $1^n$, outputs $(I, \mathsf{td})$ with $\left| I \right| \geq n$. Each
  value of $I$ defines a set $D_I$ that constitutes the domain and range of a
  permutation (i.e., bijection) $f_I \colon D_I -> D_I$.
    \item Let $\mathsf{Gen}_1$ denote the algorithm that results by
  running \textsf{Gen} and outputting only $I$. Then
  $(\mathsf{Gen}_1, \mathsf{Samp}, f)$ is a family of one-way permutations.
    \item Let $(I, \mathsf{td})$ be an output of $\mathsf{Gen}(1^n)$. The
  deterministic inverting algorithm \textsf{Inv}, on input \textsf{td} and $y \in
  D_I$, outputs $x \in D_I$. We denote this by
  $x \coloneqq \mathsf{Inv}_{\mathsf{td}}(y)$. It is required that with all but
  negligible probability over $(I, \mathsf{td})$ output by $\mathsf{Gen}(1^n)$
  and uniform choice of $x \in D_I$, we have $\mathsf{Inv}_{\mathsf{td}}(f_I(x)) =
  x$.
  \end{itemize}
\end{definition}

\section{Universally Composable Commitment Protocol}
\begin{algorithm}
\SetAlgorithmName{Protocol}{protocol}{List of Protocols}
\DontPrintSemicolon

\SetKwBlock{Parameters}{\textnormal{\textsf{Public strings}:}}{}
\Parameters{
  $\sigma$: Random string in $\{0,1\}^{4n}$\;
  ${pk}_0, {pk}_1$: Keys for generator $G_{k} \colon \{0,1\}^n \to \{0,1\}^{4n}$
}\smallskip
\SetKwBlock{Commit}{\textnormal{\textsf{Commit}($b$):}}{}
\Commit{
  $r \leftarrow \{0, 1\}^n$\;
  $x \coloneqq G_{{pk}_b}(r)$\;
  if $b=1$ then $x \coloneqq x \oplus \sigma$\;
  Send $(\mathsf{Commit}, x)$ to receiver.\;
  Upon receiving $(\mathsf{Commit}, x)$ from $A$, $B$ outputs $(\mathsf{Receipt})$.
}\smallskip

\SetKwBlock{Decommit}{\textnormal{\textsf{Decommit}($x$):}}{}
\Decommit{
  Send $(b, r)$ to receiver.\;
  Receiver checks $x = G_{{pk}_b}(r)$ for $b = 0$, or $x = G_{{pk}_b}(r) \oplus \sigma$
  for $b = 1$. If verification succeeds, then $B$ outputs $(\mathsf{Open}, b)$.
}
\caption{Universally Composable Commitment}
\label{alg:com}
\end{algorithm}

\section{Extending ILC with Trapdoor Permutations}

UC Commitments are realized from cryptographic primitives, such as trapdoor
permutations, which require extensions to ILC. The new syntactic forms are
\textsf{kgen}, \textsf{tdp}, \textsf{inv}, and \textsf{hc} with the static and
dynamic semantics shown in Figure~\ref{fig:extended-ilc}. The semantics are
written in terms of the cryptographic objects themselves.

\todo{Probably move these details to the appendix?} The key generation function
\textsf{keygen} takes as input a security parameter and outputs a random public
key $v_{pk}$ and a trapdoor $v_{td}$. The trapdoor permutation function
\textsf{tdp} takes as inputs a key $v_{pk}$ and a bitstring $v_{in}$ and outputs
a bitstring $v_{out}$. \todo{Inverse.} The hardcore predicate function
\textsf{hc} takes as input a key $v_{pk}$ and outputs a single bit. \todo{These
  require a bit of background...}

\input{figures/ilc/extended-syntax}

\todo{Give definition of PRG somwhere.} We can use these to implement a special
pseudorandom number generator $G_{pk}
\colon \{0,1\}^k \to \{0,1\}^{4k}$ that has a trapdoor property, i.e., it is easy
to compute, but difficult to invert except with special information called the
``trapdoor.''
\[ G_{pk}(r) = \big(\mathbf{f}_{pk}^{(3n)}(r),
\mathbf{B}(\mathbf{f}_{pk}^{(3n-1)}(r)), \ldots, \mathbf{B}(\mathbf{f}_{pk}(r)),
\mathbf{B}(r)\big)\]
\noindent Here, $\mathbf{f}_{pk}$ is a trapdoor permutation over $\{0,1\}^{k}$,
with $\mathbf{f}_{pk}^{(i)}(r)$ denoting the $i^{\textnormal{th}}$-fold
application of $\mathbf{f}_{pk}$, and $\mathbf{B}$ is a hardcore predicate for
$\mathbf{f}_{pk}$. In ILC, this can be implemented as:
\lstinputlisting[style=myilc]{listings/prg.ilc}

\input{sections/ilcproofs}
