\appendix

\section{Algorithmic Type Checking}
\label{sec:algo-type-check}

Figure~\ref{fig:alg-type-check} gives the algorithmic type checking rules.

\begin{figure*}
\centering
\judgbox{\Delta_{in} ; \Gamma_1 |- e : \Delta_{out}; \Gamma_2; A}{~~Under $\Delta_{in}$ and
  $\Gamma_1$, expression~$e$ results $\Delta_{out}$ and $\Gamma_2$ and has intuitionistic type $A$.}
\begin{mathpar}
\Infer{a-var}
{\Gamma(x) = A}
{\Delta; \Gamma |- x : \Delta; \Gamma; A}
%
\and
%
\Infer{a-unit}
{ }
{\Delta ; \Gamma |- \eUnit : \Delta; \Gamma; \tyUnit}
%
\and
%
\Infer{a-pair}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A_1\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; A_2}
{\Delta_1; \Gamma |- \ePair{e_1}{e_2} : \Delta_3; \Gamma;  \tyProd{A_1}{A_2}}
%
\and
%
\Infer{a-inj}
{i \in \{1, 2\}\\\\
\Delta_1; \Gamma |- e : \Delta_2; \Gamma; A_i}
{\Delta_1 ; \Gamma |- \eInj{i}{e} : \Delta_2; \Gamma; \tySum{A_1}{A_2}}
%
\and
%
\Infer{a-ref}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; A}
{\Delta_1; \Gamma |- \eRef{e} : \Delta_2; \Gamma; \tyRef{A}}
%
\and
%
\Infer{a-split}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyProd{A_1}{A_2}\\\\
\Delta_2; \Gamma,x_1:A_1, x_2: A_2 |- e : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eSplit{e_1}{x_1}{x_2}{e_2} : \Delta_3; \Gamma; B}
%
\and
%  
\Infer{a-case}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; \tySum{A_1}{A_2}\\\\
\Delta_2; \Gamma,x_1:A_1 |- e_1 : \Delta_3; \Gamma; B\\\\
\Delta_2; \Gamma,x_2:A_2 |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eCase{e}{x_1}{e_1}{x_2}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-get}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; \tyRef{A}}
{\Delta_1; \Gamma |- \eGet{e} : \Delta_2; \Gamma; A}
%
\and
%
\Infer{a-set}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyRef{A}\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; A}      
{\Delta_1; \Gamma |- \eSet{e_1}{e_2} : \Delta_3; \Gamma; \tyUnit}
%
\and
%
\Infer{a-fix}
{\Delta_1; \Gamma,x : \tyArr{A}{\footnotesize m}{A} |- e : \Delta_2; \Gamma; \tyArr{A}{\footnotesize m}{A}}
{\Delta_1; \Gamma |- \eFix{x}{e} : \Delta_2; \Gamma; \tyArr{A}{\footnotesize m}{A}}
%
\and
%
\Infer{a-let}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma, x:A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLet{x}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-let!}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma, x:A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLetBang{x}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-abs}
{\Delta_1 ; \Gamma, x:A |- e : \Delta_2; \Gamma; B}
{\Delta_1 ; \Gamma |- \eLam{x}{e} : \Delta_2; \Gamma; \tyArr{A}{\footnotesize m}{B}}
%
\and
%
\Infer{a-app}
{\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_1 : \Delta_3; \Gamma; \tyArr{A}{\footnotesize m}{B}}
{\Delta_1; \Gamma |- \eApp{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-nu}
{\Delta_1, x_1: \tyRd{A} ; \Gamma, x_2 : \tyWr{A} |- e : \Delta_2; \Gamma; B}
{\Delta_1; \Gamma |- \eNu{(x_1, x_2)}{e} : \Delta_2; \Gamma; B}
%
\and
%
\Infer{a-wr}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; \tyWr{A}}
{\Delta_1; \Gamma|- \eWr{e_1}{e_2} : \Delta_3; \Gamma; \tyUnit}
%
\and
%
\Infer{a-letrd}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyRd{A}\\\\
\Delta_2, x_2 : \tyRd{A} ; \Gamma, x_1 : A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLetRd{x_1}{x_2}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-fork}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eFork{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-choice}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; A}
{\Delta_1; \Gamma |- \eChoice{e_1}{e_2} : \Delta_2; \Gamma; A}
\end{mathpar}

\judgbox{\Delta_{in} ; \Gamma_1 |- e : \Delta_{out}; \Gamma_2; A}{~~Under $\Delta_{in}$ and
  $\Gamma_1$, expression~$e$ results $\Delta_{out}$ and $\Gamma_2$ and has affine type $A$.}
\begin{mathpar}
\Infer{a-lvar}
{\Delta(x) = A}
{\Delta; \Gamma |- x : \Delta ; \Gamma; A}
%
\and
%
\Infer{a-tensor}
{\Delta_1; \Gamma |- e_1 : \Delta_2 ; \Gamma ; X_1\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3 ; \Gamma ; X_2}
{\Delta_1, \Delta_2; \Gamma |- \ePair{e_1}{e_2} : \Delta_3 ; \Gamma ; \tyTensor{X_1}{X_2}}
%
\and
%
\Infer{a-bang}
{\Delta_1 ; \Gamma |- e : \Delta_2 ; \Gamma ; A }
{\Delta_1 ; \Gamma |- \eBang{e} : \Delta_2 ; \Gamma ; \tyBang{A}}
%
\and
%
\Infer{a-lfix}
{\Delta_1, x : \tyLolli{X}{\footnotesize m}{X}; \Gamma |- e : \Delta_ 2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{X}}
{\Delta_1; \Gamma |- \eLfix{x}{e} : \Delta_2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{X}}
%
\and
\Infer{a-lolli}
{\Delta_1,x:X ; \Gamma |- e : \Delta_2 ; \Gamma ; Y}
{\Delta_1 ; \Gamma |- \eLAM{x}{e} : \Delta_2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{Y}}
\end{mathpar}
\caption{Algorithmic typing rules.}
\label{fig:alg-type-check}
\end{figure*}

\section{\textsf{execUC}}
\label{sec:full-execUC}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/suc.ilc}
\caption{Full definition of \textsf{execUC}.}
\label{fig:execUC}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/wrapper.ilc}
\caption{Party wrapper.}
\label{fig:wrapper}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/dummy.ilc}
\caption{Dummy adversary.}
\label{fig:dummy-adversary}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/dummyp.ilc}
\caption{Dummy party.}
\label{fig:dummy-party}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/Fcrs.ilc}
\caption{Ideal functionality for common reference string (CRS).}
\label{fig:f-crs}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/sim.ilc}
\caption{Simulator for UC commitment.}
\label{fig:sim}
\end{figure*}

\section{Cryptography Definitions}

\begin{definition}[Interactive Turing Machine]
\end{definition}

\begin{definition}[Trapdoor Permutations~\cite{lindell2014introduction}]
  A tuple of polynomial-time algorithms $(\mathsf{Gen}, \mathsf{Samp},
  f, \textsf{Inv})$ is a family of trapdoor permutations if:
  \begin{itemize}[leftmargin=*]
    \item The probabilistic parameter-generation algorithm \textsf{Gen}, on
  input $1^n$, outputs $(I, \mathsf{td})$ with $\left| I \right| \geq n$. Each
  value of $I$ defines a set $D_I$ that constitutes the domain and range of a
  permutation (i.e., bijection) $f_I \colon D_I -> D_I$.
    \item Let $\mathsf{Gen}_1$ denote the algorithm that results by
  running \textsf{Gen} and outputting only $I$. Then
  $(\mathsf{Gen}_1, \mathsf{Samp}, f)$ is a family of one-way permutations.
    \item Let $(I, \mathsf{td})$ be an output of $\mathsf{Gen}(1^n)$. The
  deterministic inverting algorithm \textsf{Inv}, on input \textsf{td} and $y \in
  D_I$, outputs $x \in D_I$. We denote this by
  $x \coloneqq \mathsf{Inv}_{\mathsf{td}}(y)$. It is required that with all but
  negligible probability over $(I, \mathsf{td})$ output by $\mathsf{Gen}(1^n)$
  and uniform choice of $x \in D_I$, we have $\mathsf{Inv}_{\mathsf{td}}(f_I(x)) =
  x$.
  \end{itemize}
\end{definition}
