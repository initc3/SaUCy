\appendix

\onecolumn
\section{Algorithmic Typing Rules}
\label{sec:algo-type-check}
\ \\

\begin{figure*}[h]
\centering
\judgbox{\Delta_{in} ; \Gamma_1 |- e : \Delta_{out}; \Gamma_2; A}{~~Under $\Delta_{in}$ and
  $\Gamma_1$, expression~$e$ results $\Delta_{out}$ and $\Gamma_2$ and has intuitionistic type $A$.}
\begin{mathpar}
\Infer{a-var}
{\Gamma(x) = A}
{\Delta; \Gamma |- x : \Delta; \Gamma; A}
%
\and
%
\Infer{a-unit}
{ }
{\Delta ; \Gamma |- \eUnit : \Delta; \Gamma; \tyUnit}
%
\and
%
\Infer{a-pair}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A_1\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; A_2}
{\Delta_1; \Gamma |- \ePair{e_1}{e_2} : \Delta_3; \Gamma;  \tyProd{A_1}{A_2}}
%
\and
%
\Infer{a-inj}
{i \in \{1, 2\}\\\\
\Delta_1; \Gamma |- e : \Delta_2; \Gamma; A_i}
{\Delta_1 ; \Gamma |- \eInj{i}{e} : \Delta_2; \Gamma; \tySum{A_1}{A_2}}
%
\and
%
\Infer{a-ref}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; A}
{\Delta_1; \Gamma |- \eRef{e} : \Delta_2; \Gamma; \tyRef{A}}
%
\and
%
\Infer{a-split}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyProd{A_1}{A_2}\\\\
\Delta_2; \Gamma,x_1:A_1, x_2: A_2 |- e : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eSplit{e_1}{x_1}{x_2}{e_2} : \Delta_3; \Gamma; B}
%
\and
%  
\Infer{a-case}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; \tySum{A_1}{A_2}\\\\
\Delta_2; \Gamma,x_1:A_1 |- e_1 : \Delta_3; \Gamma; B\\\\
\Delta_2; \Gamma,x_2:A_2 |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eCase{e}{x_1}{e_1}{x_2}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-get}
{\Delta_1; \Gamma |- e : \Delta_2; \Gamma; \tyRef{A}}
{\Delta_1; \Gamma |- \eGet{e} : \Delta_2; \Gamma; A}
%
\and
%
\Infer{a-set}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyRef{A}\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; A}      
{\Delta_1; \Gamma |- \eSet{e_1}{e_2} : \Delta_3; \Gamma; \tyUnit}
%
\and
%
\Infer{a-fix}
{\emptyctxt; \Gamma,x : \tyArr{A}{\footnotesize m}{A} |- e : \emptyctxt; \Gamma; \tyArr{A}{\footnotesize m}{A}}
{\Delta; \Gamma |- \eFix{x}{e} : \Delta; \Gamma; \tyArr{A}{\footnotesize m}{A}}
%
\and
%
\Infer{a-let}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma, x:A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLet{x}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-let!}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma, x:A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLetBang{x}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-abs}
{\emptyctxt ; \Gamma, x:A |- e : \emptyctxt; \Gamma; B}
{\Delta ; \Gamma |- \eLam{x}{e} : \Delta; \Gamma; \tyArr{A}{\footnotesize m}{B}}
%
\and
%
\Infer{a-app}
{\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_1 : \Delta_3; \Gamma; \tyArr{A}{\footnotesize m}{B}}
{\Delta_1; \Gamma |- \eApp{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-nu}
{\Delta_1, x_1: \tyRd{A} ; \Gamma, x_2 : \tyWr{A} |- e : \Delta_2; \Gamma; B}
{\Delta_1; \Gamma |- \eNu{(x_1, x_2)}{e} : \Delta_2; \Gamma; B}
%
\and
%
\Infer{a-wr}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; \tyWr{A}}
{\Delta_1; \Gamma|- \eWr{e_1}{e_2} : \Delta_3; \Gamma; \tyUnit}
%
\and
%
\Infer{a-letrd}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyRd{A}\\\\
\Delta_2, x_2 : \tyRd{A} ; \Gamma, x_1 : A |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eLetRd{x_1}{x_2}{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-fork}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3; \Gamma; B}
{\Delta_1; \Gamma |- \eFork{e_1}{e_2} : \Delta_3; \Gamma; B}
%
\and
%
\Infer{a-choice}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; A\\\\
\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; A}
{\Delta_1; \Gamma |- \eChoice{e_1}{e_2} : \Delta_2; \Gamma; A}
\end{mathpar}

\judgbox{\Delta_{in} ; \Gamma_1 |- e : \Delta_{out}; \Gamma_2; A}{~~Under $\Delta_{in}$ and
  $\Gamma_1$, expression~$e$ results $\Delta_{out}$ and $\Gamma_2$ and has affine type $A$.}
\begin{mathpar}
\Infer{a-avar}
{\Delta(x) = X}
{\Delta; \Gamma |- x : \Delta ; \Gamma; X}
%
\and
%
\Infer{a-bang}
{\emptyctxt ; \Gamma |- e : \emptyctxt ; \Gamma ; A}
{\Delta ; \Gamma |- \eBang{e} : \Delta ; \Gamma ; \tyBang{A}}
%
\and
%
\Infer{a-tensor}
{\Delta_1; \Gamma |- e_1 : \Delta_2 ; \Gamma ; X_1\\\\
\Delta_2; \Gamma |- e_2 : \Delta_3 ; \Gamma ; X_2}
{\Delta_1, \Delta_2; \Gamma |- \eLPair{e_1}{e_2} : \Delta_3 ; \Gamma ; \tyTensor{X_1}{X_2}}
%
\and
%  
\Infer{a-asplit}
{\Delta_1; \Gamma |- e_1 : \Delta_2; \Gamma; \tyTensor{X_1}{X_2}\\\\
\Delta_2,x_1:X_1, x_2: X_2; \Gamma |- e : \Delta_3; \Gamma; Y}
{\Delta_1; \Gamma |- \eLsplit{e_1}{x_1}{x_2}{e_2} : \Delta_3; \Gamma; Y}
%
\and
%
\Infer{a-afix}
{\Delta_1, x : \tyLolli{X}{\footnotesize m}{X}; \Gamma |- e : \Delta_ 2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{X}}
{\Delta_1; \Gamma |- \eLfix{x}{e} : \Delta_2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{X}}
%
\and
\Infer{a-lolli}
{\Delta_1,x:X ; \Gamma |- e : \Delta_2 ; \Gamma ; Y}
{\Delta_1 ; \Gamma |- \eLAM{x}{e} : \Delta_2 ; \Gamma ; \tyLolli{X}{\footnotesize m}{Y}}
%
\and
%
\Infer{a-aapp}
{\Delta_1; \Gamma |- e_2 : \Delta_2; \Gamma; X\\\\
\Delta_2; \Gamma |- e_1 : \Delta_3; \Gamma; \tyLolli{X}{\footnotesize m}{Y}}
{\Delta_1; \Gamma |- \eLapp{e_1}{e_2} : \Delta_3; \Gamma; Y}
\end{mathpar}
\caption{Algorithmic typing rules.}
\label{fig:alg-type-check}
\end{figure*}

\twocolumn
\section{\textsf{execUC}}
\label{sec:full-execUC}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/suc.ilc}
\caption{Full definition of \textsf{execUC}. The channels follow a uniform
naming scheme. The read end of a channel is prefixed with \textsf{r-} and the
write end of a channel is prefixed with \textsf{w-}. The channel \textsf{rZ2P}
denotes the read end of communications from the environment \textsf{z} to the
party \textsf{p}. First, the random bitstring is split amongst each of the five
parties. Then, the functionality, the adversary, and both protocol parties are
spawned in a child process (given the appropriate channels and parameters), and
the process continues as the environment process. Notice that parties are run in
wrapper functions, which alter their behavior depending on whether or not they
are corrupted. If a party is corrupted, then the adversary masquerades as the
party. The mode carried over the rightmost lollipop is $m \in \{(\mathsf{m}_{\mathsf{f}},\mathsf{m}_{\mathsf{a}},\mathsf{m_{\mathsf{z}}) \mid \mathsf{m}_{\mathsf{f}}
|| (\mathsf{m}_{\mathsf{a}} || (\mathsf{R} || (\mathsf{R}
|| \mathsf{m}_{\mathsf{z}}))) => \mathsf{m}_{\mathsf{e}}}\}$.}
\label{fig:execUC}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/dummy.ilc}
\caption{Dummy adversary. The dummy adversary forwards messages from the
environment to either the functionality (if the message has
constructor \textsf{A2F}) or the party \textsf{p} (if the message has
constructor \textsf{A2P}). Similarly, the dummy adversary forwards messages from
the functionality or the procotol parties to the environment.}
\label{fig:dummy-adversary}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/dummyp.ilc}
\caption{Dummy party. The dummy party simply relays information between the
environment and the functionality.}
\label{fig:dummy-party}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/Fcrs.ilc}
\caption{Ideal functionality for common reference string (CRS). \todo{keygen?}}
\label{fig:f-crs}
\end{figure*}

%\begin{figure*}
%\lstinputlisting[style=myilc]{listings/committer.ilc}
%\caption{Universally composable commitment committer.}
%\label{fig:committer}
%\end{figure*}
%
%\begin{figure*}
%\lstinputlisting[style=myilc]{listings/receiver.ilc}
%\caption{Universally composable commitment receiver.}
%\label{fig:receiver}
%\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/sim.ilc}
\caption{Ideal world simulator for UC commitment.}
\label{fig:sim}
\end{figure*}

\begin{figure*}
\lstinputlisting[style=myilc]{listings/simR.ilc}
\caption{Real world simulator for UC commitment.}
\label{fig:simR}
\end{figure*}


\begin{comment}
\section{Cryptography Definitions}


\subsection{Brain Dump}

\begin{definition}[Protocol Emulation]
Let $\pi$ and $\phi$ be probabilistic polynomial time (p.p.t) protocols. We say
that $\pi$ UC-emulates $\phi$ if for any p.p.t. adversary $\mc{A}$ there exists a
p.p.t. ideal-process adversary $\mc{S}$ such that for any balanced PPT environment
$\mc{Z}$ we have:
\begin{equation*}
\textsc{Exec}_{\phi, \mc{S}, \mc{Z}} \approx \textsc{Exec}_{\pi, \mc{A}, \mc{Z}}.
\end{equation*}
\end{definition}

\begin{lemma}[Protocol Emulation w.r.t. the Dummy Adversary]
Let $\pi$ and $\phi$ be probabilistic polynomial time (p.p.t) protocols. We say
that $\pi$ UC-emulates $\phi$ if for the dummy adversary $\mc{D}$ there exists a
p.p.t. ideal-process adversary $\mc{S}$ such that for any balanced PPT environment
$\mc{Z}$ we have:
\begin{equation*}
\textsc{Exec}_{\phi, \mc{S}, \mc{Z}} \approx \textsc{Exec}_{\pi, \mc{D}, \mc{Z}}.
\end{equation*}
\end{lemma}

\begin{theorem}[Universal Composition]
  Let $\rho$, $\pi$, and $\phi$, be p.p.t protocols such that $\pi$ UC-emulates $\phi$ and
  both $\phi$ and $\pi$ are subroutine respecting. Then protocol $\rho^{\phi -> \pi}$
  UC-emulates protocol $\rho$.
\end{theorem}

\begin{corollary}
  Let $\rho$, $\pi$ be p.p.t protocols such that $\pi$ UC-realizes a p.p.t ideal
  functionality $\mc{F}$, and both $\rho$ and $\pi$ are subroutine respecting. Then
  protocol $\rho^{\pi/\mc{F}}$ UC-emulates protocol $\rho$.
\end{corollary}

\begin{corollary}[Universal Composition: Realizing Functionalities]
  Let $\mc{F}$, $\mc{G}$ be ideal functionalities such that $\mc{F}$ is
  p.p.t. Let $\rho$ be a subroutine respecting protocol that UC-realizes $\mc{G}$,
  and let $\pi$ be a subroutine respecting protocol that UC-realizes
  $\mc{F}$. Then the composed protocol $\rho^{\pi/\mc{F}}$ securely realizes $\mc{G}$.
\end{corollary}

\begin{theorem}
  Protocol $\Pi_{\textsc{com}}$ securely realizes functionality
  $\Func_{\textsc{com}}$ in the CRS model.
\end{theorem}

Let {\sf Bit} be the type of single bits (i.e., 0 or 1), and let {\sf Inf} be
the type of infinite bitstrings. The meaning of an ILC term $\tau$ is given by the
denotation $[\![\tau]\!]\sigma$, which returns, for an infinite bitstring $\sigma{:}{\sf Inf}$, a value
$v{:}{\sf Bit}$. The denotation $[\![\tau]\!]$, then, returns a binary
distribution $d$ over the types of return values for all infinite
bitstrings. Let $\Delta(d_1, d_2)$ denote the statistical distance between two
distributions $d_1$ and $d_2$.
%\[ \Delta(d_1, d_2) \defeq max_{A}|d_1 A - d_2 A|\]

\begin{definition}[$\epsilon$-indistinguishability of ILC Terms]
Let $\tau_1$ and $\tau_2$ be ILC terms, which are closed except for an infinite
bitstream free variable $\sigma{:}{\sf Inf}$. Additionally, for any such $\sigma$,
$[\![t_1]\!]\sigma{:}{\sf Bit}$ and $[\![\tau_2]\!]\sigma{:}{\sf Bit}$. We say that $\tau_1$ and
$\tau_2$ are $\epsilon$-indistinguishable iff $\Delta([\![\tau_1]\!], [\![\tau_2]\!]) \leq \epsilon$.
\end{definition}

\begin{definition}[Probability Distribution Ensemble]
An \emph{ensemble} of probability distributions is a family of probability
distributions $\{ X_{\lambda, z} \}_{\lambda \in \mathbb{N}, z \in {\{0,1\}}^{*}}$ with index
set $\mathbb{N} \times \{0,1\}^{*}$.  The ensembles considered in this work are binary probability
distribution ensembles, which describe single bit outputs of computations, where
$\lambda \in \mathbb{N}$ represents the security parameter, and $z \in \{0,1\}^{*}$
represents input.
\end{definition}

\begin{definition}[Indistinguishability]
Let $X$ and $Y$ be two binary probability distribution
ensembles. We say that $X$ and $Y$ are indistinguishable
(written $X \approx Y$) if for any $c, d \in \mathbb{N}$, there exists
$\lambda_0 \in \mathbb{N}$ such that for all $\lambda > \lambda_0$ and all $z \in \cup_{\lambda \leq \lambda^d}\{0,1\}^{\lambda}$,
\[ | \Pr[X_{\lambda, z} = 1] - \Pr[Y_{\lambda, z} = 1] | < \lambda^{-c}. \]
\end{definition}

\begin{definition}[Bit Producing ILC Term]
Let $\tau$ be an ILC term. We say that $\tau$ is bit producing if it is closed except
for an infinite bitstream free variable $\sigma{:}{\sf Inf}$ and $\sigma{:}{\sf Inf} \vdash
\tau{:}{\sf Bit}$.
%security parameter in judgement
%and converging
\end{definition}

\noindent The denotation $[\![\tau]\!]\sigma$, in which a particular $\sigma$ is
given, evaluates to a value of type {\sf Bit}, and the denotation $[\![\tau]\!]$,
in which no $\sigma$ is specified, evaluates to a binary probability distribution
ensemble over types or values?

\begin{definition}[Indistinguishability of Bit Producing ILC Terms]
Let $\tau_1$ and $\tau_2$ be bit producing ILC terms. We say that $\tau_1$ and $\tau_2$ are
indistinguishable terms if the binary probability distribution ensembles
$[\![\tau_1]\!]$ and $[\![\tau_2]\!]$ are indistinguishable.
\end{definition}
%tau is an ILC+ stream w/ infinite streams and security parameter

\begin{definition}[Protocol Emulation in ILC]
Let $(\pi_1, \mc{F}_1)$ and $(\pi_2, \mc{F}_2)$ be two protocol-functionality
pairs. We say that $(\pi_1, \mc{F}_1)$ UC-emulates $(\pi_2, \mc{F}_2)$ iff for all
adversaries $\mc{A}$, there exists an ideal-process adversary $\mc{S}$ such that
for any environment $\mc{Z}$,
$\textsc{ExecUC}_{\mc{Z}, \mc{A}, \pi_1, \mc{F}_1}$ and
$\textsc{ExecUC}_{\mc{Z}, \mc{S}, \pi_2, \mc{F}_2}$ are bit producing and
indistinguishable terms.
% ExecUC should have sigma and parameter as free variables
% bit respecting adversaries and environments
% first define constraints pi and F for divergence wrt A and Z
\end{definition}

\begin{definition}[Protocol Emulation in ILC]
Let $\pi$ and $\phi$ be probabilistic polynomial time (p.p.t.) protocols. We say that
$\pi$ UC-emulates $\phi$ if for any p.p.t. adversary 
$\mc{A}$, there exists a p.p.t. ideal-process adversary $\mc{S}$
such that for any balanced p.p.t. environment $\mc{Z}$,
$\textsc{ExecUC}_{\phi, \mc{S}, \mc{Z}}$ and $\textsc{ExecUC}_{\pi, \mc{A}, \mc{Z}}$
are indistinguishable bit producing terms.
\end{definition}

\begin{definition}[Protocol Emulation in ILC]
Let $\pi$ and $\phi$ be protocols. We say that $\pi$ UC-emulates $\phi$ iff for all
adversaries $\mc{A}$, there exists an ideal-process adversary $\mc{S}$ such that
for any environment $\mc{Z}$,
$\textsc{ExecUC}[\pi, \mc{A}, \mc{Z}, \lambda, \sigma]$ and
$\textsc{ExecUC}[\phi, \mc{S}, \mc{Z}, \lambda, \sigma]$ are bit producing and
indistinguishable terms.
\end{definition}

\begin{definition}[Balanced Environment]
An environment $\mc{Z}$ is balanced if the overall length of inputs given by
$\mc{Z}$ to the parties of the main instance $\pi$ is at most $k$ times the length
of the input to the adversary.
\end{definition}

Environment should activate the adversary to allow sending of messages.

\begin{definition}[Interactive Turing Machine]
\end{definition}

\begin{definition}[Trapdoor Permutations~\cite{lindell2014introduction}]
  A tuple of polynomial-time algorithms $(\mathsf{Gen}, \mathsf{Samp},
  f, \textsf{Inv})$ is a family of trapdoor permutations if:
  \begin{itemize}[leftmargin=*]
    \item The probabilistic parameter-generation algorithm \textsf{Gen}, on
  input $1^n$, outputs $(I, \mathsf{td})$ with $\left| I \right| \geq n$. Each
  value of $I$ defines a set $D_I$ that constitutes the domain and range of a
  permutation (i.e., bijection) $f_I \colon D_I -> D_I$.
    \item Let $\mathsf{Gen}_1$ denote the algorithm that results by
  running \textsf{Gen} and outputting only $I$. Then
  $(\mathsf{Gen}_1, \mathsf{Samp}, f)$ is a family of one-way permutations.
    \item Let $(I, \mathsf{td})$ be an output of $\mathsf{Gen}(1^n)$. The
  deterministic inverting algorithm \textsf{Inv}, on input \textsf{td} and $y \in
  D_I$, outputs $x \in D_I$. We denote this by
  $x \coloneqq \mathsf{Inv}_{\mathsf{td}}(y)$. It is required that with all but
  negligible probability over $(I, \mathsf{td})$ output by $\mathsf{Gen}(1^n)$
  and uniform choice of $x \in D_I$, we have $\mathsf{Inv}_{\mathsf{td}}(f_I(x)) =
  x$.
  \end{itemize}
\end{definition}

\end{comment}

\section{Universally Composable Commitment Protocol}
In this section we give the full elaboration of our UC commitment instantiation.
The specification functionality is given in the body in Figure~\ref{func:com},
along with the protocol implementation in Section~\ref{subsec:example}.
Our development follows closely from the psuedocode in the UC literature~\cite{canetti2001commitments}, which we show here in Algorithm~\ref{alg:com}.
The protocol relies on the CRS functionality which we define here in Figure~\ref{fig:f-crs}.
To briefly summarize what is going: the setup CRS samples a random string $\sigma$ and two trapdoor pseudorandom generators (prgs).
To commit to the bit $b$, the commiter produces a string $y$ that is the result of applying one or the other of the prgs, and if $b=1$ additionally applying xor with $\sigma$.
The intuitive explanation why this is hiding is that without the trapdoor, it is difficult to tell whether a random $4k$-bit string is in the range of either prg. To open the commitment, the committer simply reveals the preimage and the receiver checks which of the two cases applies. The intuitive explanation why this is binding is that it is difficult to find a pair $y,y\oplus\sigma$ that are respectively in the range of both prgs.

The UC proof consists of two simulators, one for the ideal world and one for the real world.
The ideal world simulator, given in Figure~\ref{fig:sim} is ported directly from the UC literature~\cite{canetti2001commitments}, while the non-standard real world simulator, given in Figure~\ref{fig:simR}, is required because our protocol emulation definition requires simulation in both directions.
The key to the ideal world simulator is to allow the simulator to generate its own CRS, for which it stores the trapdoors. The string $\sigma$ is not truly random, but instead is the result of combining two evaluations of the prgs.
The ideal world simulator consists of two cases, depending on which of the parties is corrupt.

In the case that the committer P is corrupt, the simulator needs to be able to \emph{extract} the committed value. The simulator is activated when $\mc{Z}$ sends a message $(\mathsf{Commit}' ~ y)$; in the real world, this is relayed by the dummy adversary to Q, who outputs \textsf{Committed} back to the environment. Hence to achieve the same effect in the ideal word, the simulator must send $(\mathsf{Commit}~b)$ to $\Func_{\textsc{Com}}$. To extract $b$ from $y$, the simulator makes use of the prg trapdoor check which one has $y$ in its range.
It is necessary to argue by cryptographic reduction that this simulation is sound.
To show this, we would define an alternative execution where the prg is substituted for a truly random function (i.e., a random oracle). If an environment $\mc{Z}$ could distinguish between these two worlds, then we could adapt the execution to distinguish the prg from random, violating the prg assumption.

In the case that the receiver Q is corrupt, the simulator needs to \emph{equivocate}.
The simulator is activated when $\mc{Z}$ inputs $(\mathsf{Commit}~b)$ to P, after which $\Func_{\mathsc{Com}}$ sends $\mathsf{Committed}$ to the simulator.
In the real world, the environment receives a commitment message $(\mathsf{Commit}'~y)$ from corrupted Q for some seemingly-random $y$. To achieve the same effect, the simulator must choose $y$. However, the simulator is next activated when the $\mc{Z}$ inputs $(\mathsf{Open}~b)$ to P, after which the simulator learns $b$ from $\Func_{\mathsc{Com}}$. However, in the real world the environment receives a valid opening $(\mathsf{Opened}'~b~r)$ that is consistent with  $y$ and with the value chosen by the environment. Thus the simulator must initially choose $y$ so that it can later be opened to either value $b$ may take. To achieve this, the CRS 

\begin{algorithm}
\SetAlgorithmName{Protocol}{protocol}{List of Protocols}
\DontPrintSemicolon

\SetKwBlock{Parameters}{\textnormal{\textsf{Public strings}:}}{}
\Parameters{
  $\sigma$: Random string in $\{0,1\}^{4n}$\;
  ${pk}_0, {pk}_1$: Keys for generator $G_{k} \colon \{0,1\}^n \to \{0,1\}^{4n}$
}\smallskip
\SetKwBlock{Commit}{\textnormal{\textsf{Commit}($b$):}}{}
\Commit{
  $r \leftarrow \{0, 1\}^n$\;
  $y \coloneqq G_{{pk}_b}(r)$\;
  if $b=1$ then $y \coloneqq y \oplus \sigma$\;
  Send $(\mathsf{Commit}, y)$ to receiver.\;
  Upon receiving $(\mathsf{Commit}, y)$ from $A$, $B$ outputs $(\mathsf{Receipt})$.
}\smallskip

\SetKwBlock{Decommit}{\textnormal{\textsf{Decommit}($x$):}}{}
\Decommit{
  Send $(b, r)$ to receiver.\;
  Receiver checks $y = G_{{pk}_b}(r)$ for $b = 0$, or $y = G_{{pk}_b}(r) \oplus \sigma$
  for $b = 1$. If verification succeeds, then $B$ outputs $(\mathsf{Open}, b)$.
}
\caption{Universally Composable Commitment}
\label{alg:com}
\end{algorithm}

\section{Extending ILC with Trapdoor Permutations}

UC Commitments are realized from cryptographic primitives, such as trapdoor
permutations, which require extensions to ILC. The new syntactic forms are
\textsf{kgen}, \textsf{tdp}, \textsf{inv}, and \textsf{hc} with the static and
dynamic semantics shown in Figure~\ref{fig:extended-ilc}. The semantics are
written in terms of the cryptographic objects themselves.

\todo{Probably move these details to the appendix?} The key generation function
\textsf{keygen} takes as input a security parameter and outputs a random public
key $v_{pk}$ and a trapdoor $v_{td}$. The trapdoor permutation function
\textsf{tdp} takes as inputs a key $v_{pk}$ and a bitstring $v_{in}$ and outputs
a bitstring $v_{out}$. \todo{Inverse.} The hardcore predicate function
\textsf{hc} takes as input a key $v_{pk}$ and outputs a single bit. \todo{These
  require a bit of background...}

\input{figures/ilc/extended-syntax}

\todo{Give definition of PRG somwhere.} We can use these to implement a special
pseudorandom number generator $G_{pk}
\colon \{0,1\}^k \to \{0,1\}^{4k}$ that has a trapdoor property, i.e., it is easy
to compute, but difficult to invert except with special information called the
``trapdoor.''
\[ G_{pk}(r) = \big(\mathbf{f}_{pk}^{(3n)}(r),
\mathbf{B}(\mathbf{f}_{pk}^{(3n-1)}(r)), \ldots, \mathbf{B}(\mathbf{f}_{pk}(r)),
\mathbf{B}(r)\big)\]
\noindent Here, $\mathbf{f}_{pk}$ is a trapdoor permutation over $\{0,1\}^{k}$,
with $\mathbf{f}_{pk}^{(i)}(r)$ denoting the $i^{\textnormal{th}}$-fold
application of $\mathbf{f}_{pk}$, and $\mathbf{B}$ is a hardcore predicate for
$\mathbf{f}_{pk}$. In ILC, this can be implemented as:
\lstinputlisting[style=myilc]{listings/prg.ilc}

\input{sections/ilcproofs}
