\input{figures/ilc/syntax}
%\input{figures/ilc/modes}
\input{figures/ilc/types}
\input{figures/ilc/semantics}

\section{Interactive Lambda Calculus}
\label{sec:ilc}

We now present the Interactive Lambda Calculus in full, formalizing its syntax,
static semantics, and dynamic semantics.

\subsection{Syntax}
\label{subsec:syntax}

The syntax of ILC is given in Figure~\ref{fig:ilc-syntax}. To make the abstract
syntax more concise, certain expressions are parameterized by a multiplicity $\pi$
to distinguish between the intuitionistic ($\infty$) and affine ($1$) counterparts;
other expressions are parameterized by a syntax label $\ell$, which includes the
multiplicity labels along with an additional write label $\wm$ (explained
shortly).

Types in ILC (written $U$, $V$) are bifurcated into intuitionistic types
(written $A$, $B$) and affine types (written $X$, $Y$). A subset of the
intuitionistic types are sendable types (written $S$, $T$), i.e., the types of
values that can be sent over channels. This restriction ensures that channels
model network channels, which send only data. The sendable types include unit
($\tyUnit$), products ($\tyProdd{}{S}{T}$), sums ($\tySum{S}{}{T}$). The
intuitionistic types include the sendable types, write channel types
($\tyWr{S}$), products ($\tyProdd{}{A}{B}$), sums ($\tySum{A}{}{B}$), arrows
($\tyArr{A}{\infty}{U}$ or simply $A -> U$), and special write arrows
($\tyArr{A}{\wm}{U}$).

The affine types include bang types ($\tyBang{A}$), read channel types
($\tyRd{S}$), products ($\tyTensor{X}{Y}$), sums ($\tyOplus{X}{Y}$), and arrows
($\tyArr{X}{1}{U}$ or simply $X \multimap U$).

Values in ILC (written $v$) include unit, pairs, sums, lambda expressions,
channels (written $c$), and banged values.

ILC supports a fairly standard feature set of expressions, with intuitionistic
variants parameterized by the label $\infty$ and affine variants parameterized by the
label $1$. The remaining syntax label $\wm$ on various introduction and
elimination forms serves two different meanings: on products and sums, it
denotes the sendable variants; on functions (abstraction, application, and fixed
points), it denotes the use of the special write functions. Bang-typed values
have introduction form $\eBang{e}$ and elimination form $\eUnbang{e}$.

The more interesting expressions are those related to communication and
concurrency:
\begin{itemize}[leftmargin=*]
  \item \emph{Restriction:} $\eNu{(x_1, x_2)}{e}$ binds a read channel $x_1$ and
    a corresponding write channel $x_2$ in $e$.
  \item \emph{Write:} $\eWr{e_1}{e_2}$ sends the evaluation of $e_1$ on
    the write channel evaluation of $e_2$.
  \item \emph{Read:} $\eLetRd{e_1}{x}{e_2}$ reads a value from the read channel
    evaluation of $e_1$ and binds the value-channel pair as $x$ in $e_2$.
  \item \emph{Choice:} $\eChoicee{e_1}{x_1}{e_3}{e_2}{x_2}{e_4}$ allows a
    process to continue as either $e_3$ or $e_4$ based on some initial read
    event on the read channel evaluations of $e_1$ and $e_2$. The value read
    over the channel and the two read channels are rebound in a 3-tuple as $x_1$
    in $e_3$ or $x_2$ in $e_4$.
  \item \emph{Fork:} $\eFork{e_1}{e_2}$ forks a child process $e_1$ and
    continues as $e_2$.
\end{itemize}

\subsection{Static Semantics}
\label{subsec:types}

A selection of typing rules are given in Figure~\ref{fig:type-expressions}. The
full set of typing rules appears in the Appendix, along with an algorithmic
version of the rules.

To recap, we read the typing judgement $\Delta; \Gamma |- e : U$ as ``under affine context
$\Delta$ and intuitionistic context $\Gamma$, expression~$e$ has type $U$.'' Additionally,
the typing rules maintain that only one process is active at any given time
(unique ownership of the write token), and the order of activations is
deterministic (unique ownership of read channels).

The typing rules for the functional fragment of ILC are fairly standard, except
that they now have intuitionistic and affine variants (and for some, sendable
variants). We explain the typing rules for which we make non-obvious design
choices for the purpose of achieving the aforementioned invariants.

The rule for intuitionistic abstraction (iabs) extends the intuitionistic
context $\Gamma$ with $x : A$ before checking the body $e$ of the abstraction. Notice
that the body must be closed with respect to the affine environment. Otherwise,
intuitionistic functions with free read channel variables could be duplicated,
thereby violating the affinity of read channels.

The rule for write abstraction (wabs) is similar to intuitionistic
abstraction. The only difference is that wabs extends the affine context with a
write token before checking the body $e$ of the abstraction. Were it not for
write abstraction, all functions would be initially read-blocked, and so one
would not be able to write a function for an ``initially activated'' process. In
order to maintain the uniqueness of the write token, the dual application rule
(wapp) stipulates that a process must own the write token in order to apply a
write abstraction.

The rule for affine abstraction (aabs) extends the affine context $\Delta$ with $x :
X$ before checking the body $e$ of the abstraction. Notice that the
body \emph{need not} be closed with respect to the affine environment, since an
affine function can only be applied once. While this may seem overly
restrictive, it turns out that most affine functions we care about do not
contain free affine variables, and so such a function $f : X \multimap U$ can be made
into an intuitionistic function $g : A -> X \multimap U$ by adding a leading
intuitionistic argument.

The typing rules for fork, write, and read were covered in
Section~\ref{subsec:type-tour}, so this leaves channel restriction (nu) and
external choice (choice) as the remaining typing rules related to communication
and concurrency.

The nu rule extends the affine context $\Delta$ with a read channel
$x_1 : \tyRd{S}$ and the intuitionistic context $\Gamma$ with a corresponding write
channel $x_2 : \tyWr{S}$ before typing the body $e$.

The choice rule partitions the affine context as $\Delta_1,\Delta_2,\Delta_3$. The first two
affine contexts are used to type $e_1 : \tyRd{S}$ and $e_2 : \tyRd{T}$,
respectively. The third affine context $\Delta_3$ is extended with the affine write
token and a variable $x_1$ (or $x_2$) binding an affine 3-tuple containing the
read value and the two read channels before checking the continuation $e_3$ (or
$e_4$). While somewhat cumbersome, this rule is general in that it allows both
read channels to be used in either continuation.

%The write token is special and unique, and need not ever be bound to a variable
%in the affine context.  Rather, it flows around “implicitly” in the program, by
%virtue of where it performs read and write effects (i.e., channel receives and
%sends).  In order to type a write expression, the write token must be present in
%the affine context. Dually, typing a read expression extends the outgoing affine
%context with the write token.

%\paragraph{Rules for preventing read nondeterminism.}
%To protect read channels from duplication, the nu rule binds read channels in
%the affine context. When reading from a channel, the letrd rule rebinds the
%channel in the affine context so that it may be used again. The rules for typing
%lambda abstractions (abs), fixed points (fix), and bang! types (bang) stipulate
%that they must be closed with respect to affine variables. Otherwise, they could
%violate the affinity of read channels.\smallskip
%
%\paragraph{Rules for preventing write nondeterminism.}
%The mode composition rules given in Figure~\ref{fig:mode-composition} prevent
%write mode processes from being composed in parallel. This is reflected in the
%fork rule, which derives the mode of $\eFork{e_1}{e_2}$ as the parallel
%composition of the mode of $e_1$ and the mode of $e_2$.
%To ensure this property is preserved during normalization, we must also forbid
%sequential composition of write mode processes.

\begin{comment}
\paragraph{Intuitionistic rules.}
The rules for intuitionistic variable lookup (var), unit (unit), and references
(ref, get, set) are standard, as are the introduction rules for products (pair)
and sums (inj). Notice that because these are all value mode expressions,
communication is not allowed in their subexpressions. On the other hand, the
elimination rules for products (split) and sums (case) do allow communication in
certain subexpressions, so it is possible to derive any mode.

The rule (abs) for intuitionistic lambda abstraction ($\eLam{x}{e}$) adds $x:A$
to the intuitionistic context $\Gamma$ before checking the body $e$, so if the body
$e$ has type $B$ and mode $m$, then the lambda abstraction has type
$\tyArr{A}{\footnotesize m}{B}$ and mode $\Vm$. There are two points worth
noting here. One is that the mode of the function body is carried by its arrow
type. The other is that the function body must be closed with respect to affine
variables, otherwise we would be able to duplicate read channels that are free
in the body. This similarly applies to the fix rule.

The dual application rule (app) says that applying a function, which carries a
mode $m$ over its arrow type, to an argument, which must have mode $\Vm$, yields
the mode $m$. And because lambda abstractions have mode $\Vm$, it follows that
partially applying a function also yields mode $\Vm$. This means that only the
rightmost arrow in a curried function type can carry a mode other than $\Vm$. In
light of this fact, we also elide value modes carried over arrows in function
signatures.

We gave a taste of let-expression typing when we introduced the letrd rule. The
rules for let and let! follow similarly, except they bind values in the
intuitionistic context (and obviously, they need not read from a channel). The
difference between let and let!, then, is that let binds an intuitionistic value
in an intuitionistic body, but let! unpacks an affine value with type
$\tyBang{A}$ to be used freely in an intuitionistic body. As with letrd, the
modes of both forms of let expressions are derived by sequentially composing the
mode of the bound expression with the mode of the body.

The rules for message passing concurrency are more interesting. The nu rule adds
the read-end of a channel $x_1: \tyRd{A}$ to the affine context $\Delta$ and its
corresponding write-end $x_2 : \tyWr{A}$ to the intuitionistic context $\Gamma$
before checking its body. We do not recap the wr and letrd rules here.

The fork rule says that that if we can appropriately split the affine context
such that the child process $e_1$ has type $A$ and mode $m_1$ and the
``continue'' process $e_2$ has type $B$ and mode $m_2$, then the whole
expression has type $B$ and mode $m_3$, which is derived by composing $m_1$ and
$m_2$ in parallel. Again, we emphasize that composing two write mode processes
in parallel violates type checking, i.e., $\Wm ;; \Wm => p$ cannot be derived
for any mode $p$.

Finally, the choice rule says that if we can appropriately split the affine
context such that both subexpressions $A$ and mode $R$, then the whole
expression follows exactly.

\paragraph{Affine rules.} The affine typing rules are, for the most part, analagous to their
intuitionistic counterparts. Two differences bear mentioning. First, the bang!
rule only lifts intuitionistically typed expressions that are closed with
respect to affine variables into an affinely typed expression. Otherwise, one
could wrap an intuitionistically typed expression with free affine variables in
a bang! and use it in an unrestricted manner. Second, in contrast with the abs
rule, the lollipop rule does not require function bodies to be free with respect
to affine variables.
\end{comment}

\subsection{Dynamic Semantics}
\label{subsec:semantics}

Figures~\ref{fig:configs} and~\ref{fig:semantics} define the dynamic syntax and
semantics of ILC, respectively.
%
We define a \emph{configuration}~$C$ as a tuple of dynamic channel and process names~$\Sigma$, 
and a pool of running and terminated processes~$\pi$.

To state and prove the meta theory of ILC (Section~\ref{sec:metatheory}), we
extend the type system given above with typing rules for
configurations, including typing environments for channels. 
%
We omit these details here for space reasons, 
and we refer the interested reader to the Appendix.
%\Secref{sec:ilcproofs}.

We read the configuration reduction judgment $C_1 ---> C_2$ as ``configuration
$C_1$ steps to configuration $C_2$,'' 
%
and the local stepping judgment $e_1 \longrightarrow e_2$ for a single process~$e$ as
``expression $e_1$ steps to expression $e_2$.
%
The rules of local stepping follow a standard call-by-value semantics, 
where we streamline the definition with an evaluation context~$E$.

Configuration stepping consists of six rules, including a congruence
rule \Rule{congr} that permits some of the other rules to be simpler,
by making the order of the pool unimportant.
%
The other fix rules consist of local stepping (via \Rule{local}),
creating new processes (via \Rule{fork}),
creating new channels (via \Rule{nu}),
read-write interactions (via \Rule{rw}),
and choice-write interactions (via \Rule{cw}).
%
To avoid allocating the same name twice, 
the name set~$\Names$ records names of allocated channels and processes.
%
Rule~\Rule{rw} uses the syntax~$R$ for a combination of several (mutually exclusive) 
reading processes, with a chosen read filling the (single) hole. \todo{Update}
%
When synchronized, 
the rule uses this syntax to eliminate all of the unchosen reading processes 
before control continues with the chosen read effect.
%
The relation $c_1 \leadsto c_2$ holds when 
channel names $c_1$ and $c_2$ refer to the 
write and read ends of a common channel.
%
(The rules abstract over how channel names, and this relation, are structured.)

%%% If you want more detail, you can uncomment this text below;
%%% However, it doesn't add much intuition beyond just reading each rule:

%% In the fork rule, the redex $\eFork{e_1}{e_2}$ in evaluation
%% context $E$ spawns a new process $e_1$ and continues by evaluating $E[e_2]$. 
%% %
%% In the nu rule,
%% the term $E[ \eNu{(x_1, x_2)}{e} ]$ reduces to $E[
%% [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]$, where $c_1$ and $c_2$ are fresh channel ends
%% added to $\Sigma$. 
%% %
%% In the rw rule, given that $c_2$ is the corresponding write
%% channel of $c_1$, denoted $c_2 \leadsto c_1$, the processes $E_1[R[ \eRd{\eChan{c_1}}]
%% ]$ and $E_2[ \eWr{\eChan{c_2}}{v}]$ step to the processes $E_1[
%% (v, \eChan{c_1})]$ and $E_2[ \eUnit]$, respectively.
