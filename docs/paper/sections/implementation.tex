\section{Implementation}
\label{sec:implementation}

We have implemented an ILC interpreter in Haskell, which at present consists of
2.3K source lines of code. We plan to open source our implementations of ILC and
SaUCy.

For economy of use, our implementation performs polymorphic type inference, and
affinity inference.

%Polymorphism on
%modes is bounded precisely due to our restriction on parallel write mode
%composition. Moreover, a consequence of any kind of mode polymorphism at all is
%that the modes of higher order functions can be dependent on the modes of its
%function arguments. We give a taste of this below.
%
%This first example features full mode polymorphism and no dependent modes.
%\lstinputlisting[style=myilc]{listings/loop.ilc}
%The \textsf{loop} function
%takes as arguments a read channel \textsf{c} and an intuitionistic function
%wrapped in a bang!, which is unpacked as \textsf{f}.  It says to first read from
%the channel \textsf{c}, unpack the read value as \textsf{v}, apply the function
%\textsf{f} to \textsf{v}, and then recursively call \textsf{loop} again. Here,
%the mode $m$ carried over the function argument is fully polymorphic, since no
%parallel compositions take place, and the function's mode $\Rm$ is monomorphic.
%
%This next example features bounded mode polymorphism and dependent modes.
%\lstinputlisting[style=myilc]{listings/par.ilc}
%The \textsf{par} function takes as arguments two functions \textsf{f} and
%\textsf{g} and a third argument \textsf{v}. It says to compute \textsf{f v} and
%\textsf{g v} in parallel. Here, because write mode expressions cannot be
%composed in parallel, at most one of the modes carried over the function
%arguments can have mode $\Wm$. Additionally, the mode \textsf{p} carried over
%the rightmost arrow is dependent on the modes of the function arguments.
