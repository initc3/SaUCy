\section{Implementation}
\label{sec:implementation}

Using this on-paper design as a guide, we have implemented an ILC interpreter in
Haskell, which at present consists of 2.3K source lines of code. The
implementation of ILC and our concrete implementation of the UC framework called
SaUCy (Section~\ref{sec:saucy}) are publicly available. Access to the latest
developments can be found here:\\
\centerline{\url{https://github.com/initc3/SaUCy}}

%Polymorphism on
%modes is bounded precisely due to our restriction on parallel write mode
%composition. Moreover, a consequence of any kind of mode polymorphism at all is
%that the modes of higher order functions can be dependent on the modes of its
%function arguments. We give a taste of this below.
%
%This first example features full mode polymorphism and no dependent modes.
%\lstinputlisting[style=myilc]{listings/loop.ilc}
%The \textsf{loop} function
%takes as arguments a read channel \textsf{c} and an intuitionistic function
%wrapped in a bang!, which is unpacked as \textsf{f}.  It says to first read from
%the channel \textsf{c}, unpack the read value as \textsf{v}, apply the function
%\textsf{f} to \textsf{v}, and then recursively call \textsf{loop} again. Here,
%the mode $m$ carried over the function argument is fully polymorphic, since no
%parallel compositions take place, and the function's mode $\Rm$ is monomorphic.
%
%This next example features bounded mode polymorphism and dependent modes.
%\lstinputlisting[style=myilc]{listings/par.ilc}
%The \textsf{par} function takes as arguments two functions \textsf{f} and
%\textsf{g} and a third argument \textsf{v}. It says to compute \textsf{f v} and
%\textsf{g v} in parallel. Here, because write mode expressions cannot be
%composed in parallel, at most one of the modes carried over the function
%arguments can have mode $\Wm$. Additionally, the mode \textsf{p} carried over
%the rightmost arrow is dependent on the modes of the function arguments.
