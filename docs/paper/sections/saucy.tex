\section{SaUCy}
\label{sec:saucy}

\input{figures/ilc/extended-syntax}

We build a concrete, executable implementation of the UC framework in ILC,
dubbed SaUCy. The \textsf{execUC} function takes as arguments an environment
\textsf{Z}, protocol parties \textsf{P} and \textsf{Q}, an adversary \textsf{A},
and a functionality \textsf{F}.

For a real world execution, programs for the actual protocol participants will be
used for \textsf{P} and \textsf{Q}, a real world adversary for \textsf{A}, and
an ideal functionality for \textsf{F} (to model \textsf{F}-hybrid
protocols). For an ideal world execution, dummy parties will be used for
\textsf{P} and \textsf{Q}, a simulator for \textsf{A}, and an ideal
functionality for \textsf{F}.

\begin{algorithm}
\SetAlgorithmName{Protocol}{protocol}{List of Protocols}
\DontPrintSemicolon

\SetKwBlock{Parameters}{\textnormal{\textsf{Public strings}:}}{}
\Parameters{
  $\sigma$: Random string in $\{0,1\}^{4n}$\;
  ${pk}_0, {pk}_1$: Keys for generator $G_{k} \colon \{0,1\}^n \to \{0,1\}^{4n}$
}\smallskip
\SetKwBlock{Commit}{\textnormal{\textsf{Commit}($b$):}}{}
\Commit{
  $r \leftarrow \{0, 1\}^n$\;
  $x \coloneqq G_{{pk}_b}(r)$\;
  if $b=1$ then $x \coloneqq x \oplus \sigma$\;
  Send $(\mathsf{Commit}, x)$ to receiver.\;
  Upon receiving (\textsf{Commit}, b) from $A$, $B$ outputs (\textsf{Receipt})
}\smallskip

\SetKwBlock{Decommit}{\textnormal{\textsf{Decommit}($x$):}}{}
\Decommit{
  Send $(b, r)$ to receiver.\;
  Receiver checks $x = G_{{pk}_b}(r)$ for $b = 0$, or $x = G_{{pk}_b}(r) \oplus \sigma$
  for $b = 1$. If verification succeeds, then $B$ outputs (\textsf{Open}, b).
}
\caption{Universally Composable Commitment}
\label{alg:com}
\end{algorithm}

\lstinputlisting[style=myilc]{listings/dummy.ilc}

\lstinputlisting[style=myilc]{listings/dummyp.ilc}

\lstinputlisting[style=myilc]{listings/wrapper.ilc}

%\lstinputlisting[style=myilc]{listings/suc.ilc}

\lstinputlisting[style=myilc]{listings/Fcrs.ilc}
