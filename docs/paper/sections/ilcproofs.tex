\section{ILC Metatheory}
\label{sec:ilcproofs}

\subsection{Additional Syntax}

We define syntax for process and channel typings, which each map a kind of
identifier (process name, or channel name) to its associated type:

\begin{grammar}
    Process pool typings
    %(maps process names to their types)
    & $\PrTy$
    &$\bnfas$& $\emptyctxt \bnfalt \PrTy,p:A \bnfalt \PrTy,p:X$
    \\
    Channel pool typings
    %(maps channel names to their types)
    & $\ChTy$
    &$\bnfas$& $\emptyctxt \bnfalt \ChTy,c:\tyRd{S} \bnfalt \ChTy,c:\tyWr{S}$
\end{grammar}

\subsection{Configuration Typings}

Using the syntax above, we define configuration typing as a straightforward extension
of single-process typing, given in \Secref{subsec:types}:\smallskip

\judgbox{\JCty{\StTy}{\ChTy}{C}{\PrTy}}{Configuration $C$ is well-typed}
\begin{mathpar}
\Infer{empty}
{ 
  %\StTy ; \ChTy |- \Store : \StTy
}
{\JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\emptyProcs}}{\cdot}}
\and
\Infer{cons}
{ \ChTy |- e : U
  \\
 \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs}}{\PrTy}}
{ \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs,p:e}}{\PrTy,p:U}}
\end{mathpar}

%Notably, parallel procesess with modes $m_1$ and $m_2$ must have modes
%that compose, where $m_1 || m_2$ is defined; this invariant ensures that there
%is at most one write mode process in a well-typed pool.

\subsection{Local Type Soundness}

We prove type soundness of the functional fragment of ILC (local type soundness)
via mostly-standard notions of progress and preservation. To state these
theorems, we follow the usual recipe, except that we give a special definition
of local process termination as follows:\smallskip

\judgbox{\Lterm{e}}{Expression $e$ is locally terminated.}
\begin{mathpar}
\Infer{val}
{ }
{\Lterm{v}}
\and  
\Infer{rdterm}
{ }
{\Lterm{\eLetRd{c}{x}{e}}}
\and
\Infer{wrterm}
{ }
{\Lterm{\eWr{c}{v}}}
\end{mathpar}
Informally, $\Lterm{e}$ holds when $e$ is a value, $e$ is reading, or $e$ is writing.

\begin{theorem}[Local Progress]
  If $\Delta; \Gamma|- e : U$, then either $\Lterm{e}$
  or there exists $e'$ such that $e -> e'$.
  \begin{proof}
    By structural induction on the derivation of $\Delta ; \Gamma|- e : U$.
  \end{proof}
\end{theorem}

\begin{theorem}[Local Preservation]
  If $\Delta; \Gamma|- e : U$ and $e -> e'$, then $\Delta; \Gamma|- e' : U$.
  \begin{proof}
    By structural induction on the derivation of $e -> e'$.
  \end{proof}
\end{theorem}

%\begin{theorem}[Local Progress]
%  If $|- e : U$, then either $\Lterm{e}$ or there exists $e'$ such that $e ->
%  e'$.
%  \begin{proof}
%    By structural induction on the derivation of $|- e : U$.
%  \end{proof}
%\end{theorem}
%
%\begin{theorem}[Local Preservation]
%  If $|- e : U$ and $e -> e'$, then $|- e' : U$.
%  \begin{proof}
%    By structural induction on the derivation of $e -> e'$.
%  \end{proof}
%\end{theorem}

\subsection{Type Soundness}

To prove type soundness of ILC, we follow the usual recipe, except that we give
a special definition of ``program termination'' (which permits deadlocks) as
follows:\smallskip

\judgbox{\JCterm{C}}{Configuration $C$ is terminated.}
\begin{mathpar}
\Infer{Cterm}
{\textrm{RdChans}(\pi) = \Sigma_1 \\ \textrm{WrChans}(\pi) = \Sigma_2\\\\
\{ (c_1,c_2) \mid c_1 \in \Sigma_1, c_2 \in \Sigma_2, c_2 \leadsto c_1\} = \varnothing}
{\JCterm{\Config{\Names}{}{\Procs}}}
\end{mathpar}
\begin{align*}
  \textrm{RdChans}(\emptyProcs) &= \emptyctxt
  &\textrm{WrChans}(\emptyProcs) &= \emptyctxt\\
  \textrm{RdChans}(\pi, p:\eLetRd{c}{x}{e}) &= \textrm{RdChans}(\pi),c
  &\textrm{WrChans}(\pi, p:\eWr{c}{v}) &= \textrm{WrChans}(\pi),c
\end{align*}
Informally, $\JCterm{C}$ holds when either:
\begin{enumerate}
 \item $C$ is fully normal: every process in~$C$ is normalized (consists of a
   value).
 \item $C$ is (at least partially) deadlocked: 
   some (possibly-empty) portion of $C$ is normal, and
   there exists one or more reading processes in $C$, or
   there exists one or more writing processes in $C$,
   however, no reader-writer pair exists for a common channel~$c$.
\end{enumerate}

\begin{lemma}[\todo{}]
  If $\ChTy |- C : \PrTy$ and $C \equiv C'$, then $\ChTy |- C' : \PrTy$.
  \begin{proof}
    By structural induction on \todo{}.
  \end{proof}
\end{lemma}

\begin{lemma}[Typability of Subterms]
  If $\mathcal{D}$ is a derivation of $\Delta; \Gamma |- E[e] : U$, then there exists $\Delta_1, \Delta_2,
  \Gamma_1,\Gamma_2$ and $V$ such that $\Delta = \Delta_1,\Delta_2$, $\Gamma = \Gamma_1,\Gamma_2$, $\mathcal{D}$ has a
  subderivation $\mathcal{D}'$ concluding $\Delta_1;\Gamma_1 |- e : V$, and the position of $\mathcal{D}'$ in
  $\mathcal{D}$ corresponds to the position of the hole in $E$.
  \begin{proof}
    By structural induction on the structure of $E$.
  \end{proof}
\end{lemma}

\begin{lemma}[Replacement (Evaluation Contexts)]
  If
  \begin{enumerate}
  \item $\mathcal{D}$ is a subderivation of $\Delta_1,\Delta_2;\Gamma_1,\Gamma_2 |- E[e] : U$,
  \item $\mathcal{D}'$ is a subderivation of $\mathcal{D}$ concluding $\Delta_2;
    \Gamma_2 |- e : V$,
  \item the position of $\mathcal{D}'$ in $\mathcal{D}$ corresponds to the
    position of the hole in $E$,
  \item $\Delta_3;\Gamma_3 |- e' : V$,
  \item $\Delta_1,\Delta_3;\Gamma_1,\Gamma_3$ is defined,
  \end{enumerate}
  then $\Delta_1,\Delta_3;\Gamma_1,\Gamma_3 |- E[e'] : U$.
  \begin{proof}
    By structural induction on the structure of $E$.
  \end{proof}  
\end{lemma}

\begin{lemma}[Substitution (Intuitionistic)]
  If
  \begin{enumerate}
  \item $\Delta_1; \Gamma_1, x : A |- e : U$,
  \item $\Delta_2; \Gamma_2 |- e' : A$,
  \item $\Delta_1,\Delta_2 ; \Gamma_1,\Gamma_2$ is defined,
  \end{enumerate}
  then $\Delta_1,\Delta_2; \Gamma_1,\Gamma_2 |- [e'/x]e : U$.
  \begin{proof}
    By structural induction on the derivation of $\Delta_1; \Gamma_1, x : A |- e : U$.
  \end{proof}
\end{lemma}

\begin{lemma}[Substitution (Affine)]
  If
  \begin{enumerate}
  \item $\Delta_1, x : X; \Gamma_1 |- e : U$,
  \item $\Delta_2; \Gamma_2 |- e' : X$,
  \item $\Delta_1,\Delta_2 ; \Gamma_1,\Gamma_2$ is defined,
  \end{enumerate}
  then $\Delta_1,\Delta_2; \Gamma_1,\Gamma_2 |- [e'/x]e : U$.
  \begin{proof}
    By structural induction on the derivation of $\Delta_1; \Gamma_1, x : A |- e : U$.
  \end{proof}
\end{lemma}

\begin{lemma}[Non-progress]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$ and $\JCterm{C}$, then there does not exist
$C'$ such that $\JCred{C}{C'}$.
\begin{proof}
    By structural induction on the derivation of $\JCty{\StTy}{\ChTy}{C}{\PrTy}$.
\end{proof}
\end{lemma}
%\begin{lemma}[Non-progress]
%For all configurations $C$,
%channel typings~$\ChTy$,
%and process typings~$\PrTy$,
%%
%if $\JCty{\StTy}{\ChTy}{C}{\PrTy}$
%and $\JCterm{C}$,
%then there does not exist $C'$ such that $\JCred{C}{C'}$.
%\begin{proof}
%    By structural induction on the derivation of $\JCty{\StTy}{\ChTy}{C}{\PrTy}$.
%\end{proof}
%\end{lemma}

\begin{theorem}[Progress]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$, then either $\JCterm{C}$, or $\exists C'$ such that
$\JCred{C}{C'}$.

%For all configurations $C$,
%channel typings~$\ChTy$,
%and process typings~$\PrTy$,
%%
%if $\JCty{\StTy}{\ChTy}{C}{\PrTy}$
%then 
%either $\JCterm{C}$,
%or $\exists C'$ such that $\JCred{C}{C'}$.
\begin{proof}
    By structural induction on the derivation of
    $\JCty{\StTy}{\ChTy}{C}{\PrTy}$.
    \begin{itemize}[leftmargin=*]
    \item[] \textbf{Case}
      \begin{mathpar}
      \Infer{empty}
      { 
        %\StTy ; \ChTy |- \Store : \StTy
      }
      {\JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\emptyProcs}}{\cdot}}
      \end{mathpar}
      \begin{llproof}
        %\Pf{\ChTy}{|-}{{\Config{\Names}{\Store}{\emptyProcs}}: \cdot}{By assumption}
        \Pf{}{}{\Sigma_1 = \textrm{RdChans}(\emptyProcs)=\emptyctxt}{By definition of RdChans}
        \Pf{}{}{\Sigma_2 = \textrm{WrChans}(\emptyProcs)=\emptyctxt}{By definition of
          WrChans}
        \Pf{}{}{\{ (c_1,c_2) \mid c_1 \in \Sigma_1, c_2 \in \Sigma_2, c_2 \leadsto c_1\} = \varnothing}{}        
        \Pf{}{}{\JCterm{{\Config{\Names}{\Store}{\emptyProcs}}}}{By Cterm}
      \end{llproof}

    \item[] \textbf{Case}
      \begin{mathpar}
      \Infer{cons}
      { \ChTy |- e : U
        \\
       \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs}}{\PrTy}}
      { \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs,p:e}}{\PrTy,p:U}}
      \end{mathpar}
      \begin{llproof}
        \Pf{}{}{\Lterm{e}~\textrm{or}~\exists e'~\textrm{s.t.}~e->e'}{By i.h.}
        \Pf{}{}{\JCterm{\Config{\Names}{\Store}{\Procs}}~\textrm{or}~\exists
          \Config{\Names'}{\Store}{\Procs'}~\textrm{s.t.}~\Config{\Names}{\Store}{\Procs}->\Config{\Names'}{\Store}{\Procs'}}{By
          i.h.}
        \proofsep
        \Pf{}{}{\textbf{Subcase}~\exists e'~\textrm{s.t.}~e->e'}{}
        \Pf{}{}{\Config{\Names}{\Store}{\Procs,p:E[e]} ->
          \Config{\Names}{\Store}{\Procs,p:E[e']}}{By rule local}

        \proofsep
        \Pf{}{}{\textbf{Subcase}~\exists\Config{\Names'}{\Store}{\Procs'}~\textrm{s.t.}~\Config{\Names}{\Store}{\Procs}->\Config{\Names'}{\Store}{\Procs'}}{}
        \Pf{}{}{\Sigma = \Sigma_1,\Sigma_2}{Suppose}
        \Pf{}{}{\Config{\Names_1,\Names_2}{\Store}{\Procs,p:e} ->
          \Config{{\Names_1}',\Names_2}{\Store}{\Procs',p:e}}{By rule frame}
        \proofsep
        \Pf{}{}{\textbf{Subcase}~\Lterm{e}~\textrm{and}~\JCterm{\Config{\Names}{\Store}{\Procs}}}{}
        \Pf{}{}{\JCterm{\Config{\Names}{\Store}{\Procs,p:e}}}{?}

      \end{llproof}
%    \item[] \textbf{Case}
%      \begin{mathpar}
%      \Infer{cons}
%      { \ChTy |- e : U
%        \\
%       \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs}}{\PrTy}}
%      { \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs,p:e}}{\PrTy,p:U}}
%      \end{mathpar}
%      \begin{llproof}
%%        \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs,p:e}{\PrTy,p:U}}{By
%%          assumption}
%        \Pf{}{}{\Lterm{e}~\textrm{or}~\exists e'~\textrm{s.t.}~e->e'}{By i.h.}
%        \Pf{}{}{\Config{\Names}{\Store}{\Procs,p:E[e]} ->
%          \Config{\Names}{\Store}{\Procs,p:E[e']}}{By $\exists e'~\textrm{s.t.}~e->e'$
%          and local}
%        \Pf{}{}{\JCterm{\Config{\Names}{\Store}{\Procs}}~\textrm{or}~\exists
%          \Config{\Names'}{\Store}{\Procs'}~\textrm{s.t.}~\Config{\Names}{\Store}{\Procs}->\Config{\Names'}{\Store}{\Procs'}}{By
%          i.h.}
%        \Pf{}{}{\JCterm{\Config{\Names}{\Store}{\Procs,p:e}}}{By $\Lterm{e}$ and
%          $\JCterm{\Config{\Names}{\Store}{\Procs}}$}
%        \Pf{}{}{\Config{\Names}{\Store}{\Procs}->\Config{\Names'}{\Store}{\Procs'}}{Above}
%        \Pf{}{}{\Config{\Names_1,\Names_2}{\Store}{\Procs,p:e} -> \Config{{\Names_1}',\Names_2}{\Store}{\Procs',p:e}}{By frame}
%      \end{llproof}                  
    \end{itemize}    
\end{proof}  
\end{theorem}

\begin{theorem}[Preservation]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$ and $\JCred{C}{C'}$, then there exists
$\ChTy' \supseteq \ChTy$ and $\PrTy' \supseteq \PrTy$ such that
$\JCty{\StTy'}{\ChTy'}{C'}{\PrTy'}$.
\begin{proof}
    By structural induction on the derivation of $\JCred{C}{C'}$.
  \begin{itemize}[leftmargin=*]
  \item[] \textbf{Case}
    \begin{mathpar}
    \Infer{rw}
    { c_2 \leadsto c_1 }
    { \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[ \eLetRd{\eChan{c_1}}{x}{e}] ], \ProcNm{q} E_2[ \eWr{\eChan{c_2}}{v}]} --->
      \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ [\ePair{!v}{\eChan{c_1}}{\wm}/x]e], \ProcNm{q}
        E_2[ \eUnit ]} }
    \end{mathpar}
    \begin{llproof}
      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[
              \eLetRd{\eChan{c_1}}{x}{e}]], \ProcNm{q} E_2[
            \eWr{\eChan{c_2}}{v}]} : \PrTy}{By assumption}
      \Pf{}{|-}{E_2[\eWr{\eChan{c_2}}{v}] : \tyUnit~\textrm{s.t.}~\ChTy(\eChan{c_2}) = \tyWr{S}~\textrm{and}~|- v : S~\textrm{for some}~S}{By inversion (wr)}
      \Pf{}{|-}{E_2[\eUnit] : \tyUnit}{By inversion (unit)}
      \Pf{}{}{c_2 \leadsto c_1}{By assumption}
      \Pf{}{}{\ChTy(\eChan{c_2}) = \tyWr{S}}{Above}      
      \Pf{}{}{\ChTy(\eChan{c_1}) = \tyRd{S}}{By definition of $\leadsto$ and
        $\ChTy(\eChan{c_2}) = \tyWr{S}$}
      \Pf{}{|-}{E_1[R[ \eLetRd{\eChan{c_1}}{x}{e}] ] :
        \tyTensor{\tyBang{S}}{\tyRd{S}}}{By inversion (rd) and
        $\ChTy(\eChan{c_1}) = \tyRd{S}$}
      \Pf{}{|-}{v : S}{Above}
      \Pf{}{|-}{E_1[ [\ePair{!v}{\eChan{c_1}}{\wm}/x]e] :
        \tyTensor{\tyBang{S}}{\tyRd{S}}}{By $|- v : S$, $\ChTy(\eChan{c_1})
        = \tyRd{S}$, and Lemma X (Substitution)}
%      \Pf{}{}{\Sigma(p) = \Sigma(p')}{By above equalities}
%      \Pf{}{}{\Sigma(q) = \Sigma(q')}{By above equalities}
      \Pf{}{}{\exists \ChTy', \PrTy'~\textrm{s.t.}~\ChTy' = \ChTy~\textrm{and}~\PrTy'
        = \PrTy}{}
      \Pf{\ChTy'}{|-}{\Config{\ChTy}{\Store}{\Procs, \ProcNm{p} E_1[ [\ePair{!v}{\eChan{c_1}}{\wm}/x]e], \ProcNm{q}
        E_2[ \eUnit ]} : \PrTy'}{}      
    \end{llproof}
    
%    Assume $|- \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[
%          \eRd{\eChan{c_1}}] ], \ProcNm{q} E_2[ \eWr{\eChan{c_2}}{v}]} :
%    \PrTy$. We show $|- \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ \ePair{!v}{\eChan{c_1}}{\wm}], \ProcNm{q}
%      E_2[ \eUnit ]} : \PrTy$ by preservation of the types of contexts $E_1$ and
%    $E_2$.
%
%    Preservation of $E_2$: By inversion, we have $|- E_2[\eWr{\eChan{c_2}}{v}] :
%    \tyUnit$ such that $\Names(\eChan{c_2}) = \tyWr{S}$ and $|- v : S$ for some
%    $S$. Also by inversion, $|- E_2[ \eUnit ] : \tyUnit$.
%
%    Preservation of $E_1$: Because $\Names(\eChan{c_2}) = \tyWr{S}$ and $c_2 \leadsto
%    c_1$, we have $\Names(\eChan{c_1}) = \tyRd{S}$. By inversion and the fact
%    $\Names(\eChan{c_1}) = \tyRd{S}$, we have $|- E_1[R[ \eRd{\eChan{c_1}}] ] :
%    \tyTensor{\tyBang{S}}{\tyRd{S}}$. By $|- v : S$ and $\Names(\eChan{c_1}) =
%    \tyRd{S}$, we have $|- E_2[ \ePair{!v}{\eChan{c_1}}{\wm}] :
%    \tyTensor{\tyBang{S}}{\tyRd{S}}$.
  \end{itemize}

\end{proof}
\end{theorem}


\subsection{Confluence}

The following lemmas state structural
invariants over write effects and read channels of a well-typed
configuration: no two writes are in parallel composition, and every read channel end is a non-duplicable (affine) resource.

\begin{lemma}[Unique writer process]
\label{lem:UniqueWriter}
If $C$ is a well-typed configuration with process pool~$\pi$, 
then there exists at most one write-mode process in $\pi$.
\begin{proof}
By structural induction over the typing derivation for $C$.
\end{proof}
\end{lemma}

\begin{lemma}[Unique reader process]
\label{lem:UniqueReader}
If $C$ is a well-typed configuration with process pool~$\pi$, 
and $c$ is a read channel in this configuration,
then there exists at most one process in $\pi$ where $c$ appears.
\begin{proof}
By structural induction over the typing derivation for $C$.
\end{proof}
\end{lemma}

\begin{theorem}[Single-step confluence]
For all well-typed configurations $C$,
%
 if $\JCred{C}{C_1}$ 
and $\JCred{C}{C_2}$ 
then 
there exists renaming function~$f$ 
such that either:
\begin{enumerate}
\item %$\JCterm{C_1}$ and 
$C_1 = f(C_2)$,
or
\item $\exists C_3$ such that $\JCred{C_1}{C_3}$ and $\JCred{f(C_2)}{C_3}$.
\end{enumerate}
\begin{proof}
   By induction on the pair of steps 
   $\left< \JCred{C}{C_1}\right.$, 
   $\left.\JCred{C}{C_2} \right>$.

   We consider the following cases:

   \emph{Case: congruence:} if either step uses \Rule{congr}, we apply the inductive hypothesis.
   
   \emph{Case: independent processes:} 
     the two steps advance distinct processes, using any of the rules \Rule{local}, \Rule{fork} and \Rule{nu},
     we produce $C_3$ by combining those two (independent) steps.     

   \emph{Case: one process:}    
   the two steps advance the same process, we show that this was
   determinisitic (up to naming) by constructing the naming function
   $f$ such that $C_2 = f(C_1)$.  Most cases are straightforward since
   they perform no non-determinisitic choices.  The only source of
   non-determinism is the name choices, in rules \Rule{nu},
   \Rule{fork}, and \Rule{new}; in each case, we map the name choice
   from the second step to that of the first step.

   \emph{Case: read-write interaction:}
   In the case that either step uses \Rule{rw}, 
   we rely on
   lemmas \ref{lem:UniqueWriter} and \ref{lem:UniqueReader}.
   to show that both steps use \Rule{rw},
   and that the reader-writer process pair is unique.
   
\end{proof}
\end{theorem}

By composing multiple uses of this theorem
we prove multi-step confluence.
However, to carry forth this composition, we need a more general
notion of single-step confluence, which is parameteric in a renaming
function for the initial configurations.

\begin{theorem}[Single-step confluence, generalized]
For all well-typed configurations $C$ 
and renaming functions $f$,
%
 if $\JCred{C}{C_1}$ 
and $\JCred{f(C)}{C_2}$ 
then 
there exists renaming function~$g$ 
such that either:
\begin{enumerate}
\item %$\JCterm{C_1}$ and 
$C_1 = g(C_2)$,
or
\item $\exists C_3$ such that $\JCred{C_1}{C_3}$ and $\JCred{g(C_2)}{C_3}$.
\end{enumerate}
\begin{proof}
  (Analogous to first single-step confluence proof.)
\end{proof}
\end{theorem}

We prove a full confluence theorem that is generalized similarly, by
accepting a renaming function~$f$ to produce a new one~$g$:

\begin{theorem}[Full confluence]
For all well-typed configurations $C$,
and renaming functions $f$,
%
 if $\JCredm{C}{C_1}$ 
and $\JCredm{f(C)}{C_2}$ 
and $\JCterm{C_1}$
and $\JCterm{C_2}$
then 
there exists renaming function~$g$ 
such that $C_1 = g(C_2)$.
\begin{proof}
  By induction on the reduction sequence pair
  $\left< \JCredm{C}{C_1}\right.$, 
  $\left.\JCredm{f(C)}{C_2} \right>$.
  Because of single-step confluence, we know that if
  if either reduction sequence is empty, then the other must be empty,
  and that
  if either takes a step, the other must take a step.
  
  \emph{Empty case:}
  When empty, we have the resulting renaming function~$g$ via single-step confluence.

  \emph{Step case:}
  We consider the case where each reduction consists of at least one step:
  $\JCred{C}{C_1'}$ and $\JCredm{C_1'}{C_1}$ and
  $\JCred{f(C)}{C_2'}$ and $\JCredm{C_2'}{C_2}$.
  By single-step confluence, we have that there exists $g_0$ such that $g_0(C_2') = C_1'$.
  By the inductive hypothesis, we have that there exists $g$ such that $C_1 = g(C_2)$.  
\end{proof}
\end{theorem}
