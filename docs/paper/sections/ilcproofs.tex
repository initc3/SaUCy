\section{Type Soundness}
\label{sec:ilcproofs}

We define syntax for process and channel typings, which each map a kind of
identifier (process name, or channel name) to its associated type:

\begin{grammar}
    Process pool typings
    %(maps process names to their types)
    & $\PrTy$
    &$\bnfas$& $\emptyctxt \bnfalt \PrTy,p:A \bnfalt \PrTy,p:X$
    \\
    Channel pool typings
    %(maps channel names to their types)
    & $\ChTy$
    &$\bnfas$& $\emptyctxt \bnfalt \ChTy,c:\tyRd{S} \bnfalt \ChTy,c:\tyWr{S}$
\end{grammar}

%\subsection{Configuration Typings}

Using the syntax above, we define configuration typing as a straightforward extension
of single-process typing, given in \Secref{subsec:types}:\smallskip

\judgbox{\JCty{\StTy}{\ChTy}{C}{\PrTy}}{Configuration $C$ is well-typed}
\begin{mathpar}
\Infer{empty}
{ 
  %\StTy ; \ChTy |- \Store : \StTy
}
{\JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\emptyProcs}}{\cdot}}
\and
\Infer{cons}
{ \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{p:e}}{p:U}\\
\JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs}}{\PrTy}}
{ \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs,p:e}}{\PrTy,p:U}}
\end{mathpar}

\subsection{Progress}
\label{subsec:label}

Progress for the functional fragment of ILC (local progress) is fairly
standard. We follow the usual recipe, except that we give a special definition
of local process termination as follows:\smallskip

\judgbox{\Lterm{e}}{Expression $e$ is locally terminated.}
\begin{mathpar}
\Infer{val}
{ }
{\Lterm{v}}
\and  
\Infer{rdterm}
{ }
{\Lterm{E[\eLetRd{c}{x}{e}]}}
\and
\Infer{chterm}
{\Lterm{e_1} \\ \Lterm{e_2}}
{\Lterm{E[\eChoice{e_1}{e_2}]}}
\and
\Infer{wrterm}
{ }
{\Lterm{E[\eWr{c}{v}]}}
\end{mathpar}
In other words, $\Lterm{e}$ holds when $e$ is a value, $e$ is reading, or $e$ is
writing.

\begin{lemma}[Local Progress]
  If $\Delta; \Gamma|- e : U$, then either $\Lterm{e}$
  or there exists $e'$ such that $e -> e'$.
  \begin{proof}
    By structural induction on the derivation of $\Delta ; \Gamma|- e : U$.
  \end{proof}
\end{lemma}

To state progress on configurations, we give a special definition of ``program
termination'' (that permits deadlocks) as follows:\smallskip

\judgbox{\JCterm{C}}{Configuration $C$ is terminated~\todo{Change RdChans and
    WrChans to use evaluation contexts?}}
\begin{mathpar}
\Infer{Cterm}
{\textrm{RdChans}(\pi) = \Sigma_1 \\ \textrm{WrChans}(\pi) = \Sigma_2\\\\
\{ (c_1,c_2) \mid c_1 \in \Sigma_1, c_2 \in \Sigma_2, c_2 \leadsto c_1\} = \varnothing}
{\JCterm{\Config{\Names}{}{\Procs}}}
\end{mathpar}
\begin{align*}
  \textrm{RdChans}(\emptyProcs) &= \emptyctxt
  &\textrm{WrChans}(\emptyProcs) &= \emptyctxt
  \\
  \textrm{RdChans}(\pi, p:\eLetRd{c}{x}{e}) &= \textrm{RdChans}(\pi),c
  &\textrm{WrChans}(\pi, p:\eWr{c}{v}) &= \textrm{WrChans}(\pi),c
  \\
  \textrm{RdChans}(\pi, p:v) &= \textrm{RdChans}(\pi),c
  &\textrm{WrChans}(\pi, p:v) &= \textrm{WrChans}(\pi),c
  \\
  \textrm{RdChans}(\pi, p:\eChoice{e_1}{e_2}) &=
  \textrm{RdChans}(p:e_1) \cup \textrm{RdChans}(p:e_2)
\end{align*}
Informally, $\JCterm{C}$ holds when either:
\begin{enumerate}
 \item $C$ is fully normal: every process in~$C$ is normalized (consists of a
   value).
 \item $C$ is (at least partially) deadlocked: 
   some (possibly-empty) portion of $C$ is normal, and
   there exists one or more reading processes in $C$, or
   there exists one or more writing processes in $C$,
   however, no reader-writer pair exists for a common channel~$c$.
\end{enumerate}

\begin{lemma}[Non-progress]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$ and $\JCterm{C}$, then there does not exist
$C'$ such that $\JCred{C}{C'}$.
\begin{proof}
    By structural induction on the derivation of $\JCty{\StTy}{\ChTy}{C}{\PrTy}$.
\end{proof}
\end{lemma}
%\begin{lemma}[Non-progress]
%For all configurations $C$,
%channel typings~$\ChTy$,
%and process typings~$\PrTy$,
%%
%if $\JCty{\StTy}{\ChTy}{C}{\PrTy}$
%and $\JCterm{C}$,
%then there does not exist $C'$ such that $\JCred{C}{C'}$.
%\begin{proof}
%    By structural induction on the derivation of $\JCty{\StTy}{\ChTy}{C}{\PrTy}$.
%\end{proof}
%\end{lemma}

\begin{theorem}[Progress]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$, then either $\JCterm{C}$, or $\exists C'$ such that
$\JCred{C}{C'}$.

%For all configurations $C$,
%channel typings~$\ChTy$,
%and process typings~$\PrTy$,
%%
%if $\JCty{\StTy}{\ChTy}{C}{\PrTy}$
%then 
%either $\JCterm{C}$,
%or $\exists C'$ such that $\JCred{C}{C'}$.
\begin{proof}
    By structural induction on the derivation of
    $\JCty{\StTy}{\ChTy}{C}{\PrTy}$.
    \begin{itemize}[leftmargin=*]
    \item[] \textbf{Case}
      \begin{mathpar}
      \Infer{empty}
      { 
        %\StTy ; \ChTy |- \Store : \StTy
      }
      {\JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\emptyProcs}}{\cdot}}
      \end{mathpar}
      \begin{llproof}
        %\Pf{\ChTy}{|-}{{\Config{\Names}{\Store}{\emptyProcs}}: \cdot}{By assumption}
        \Pf{}{}{\Sigma_1 = \textrm{RdChans}(\emptyProcs)=\emptyctxt}{By definition of RdChans}
        \Pf{}{}{\Sigma_2 = \textrm{WrChans}(\emptyProcs)=\emptyctxt}{By definition of
          WrChans}
        \Pf{}{}{\{ (c_1,c_2) \mid c_1 \in \Sigma_1, c_2 \in \Sigma_2, c_2 \leadsto c_1\} = \varnothing}{}        
        \Pf{}{}{\JCterm{{\Config{\Names}{\Store}{\emptyProcs}}}}{By rule Cterm}
      \end{llproof}

    \item[] \textbf{Case}
      \begin{mathpar}
      \Infer{cons}
      { \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{p:e}}{p:U}
        \\
       \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs}}{\PrTy}}
      { \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs,p:e}}{\PrTy,p:U}}
      \end{mathpar}
      
      \begin{llproof}
        \Pf{}{}{\JCterm{\Config{\Names}{\Store}{p:e}}~\textrm{or}~\exists
          \Config{\Names'}{\Store}{p:e'}~\textrm{s.t.}~\Config{\Names}{\Store}{p:e}->\Config{\Names'}{\Store}{p:e'}}{By
          i.h.}        
        \Pf{}{}{\JCterm{\Config{\Names}{\Store}{\Procs}}~\textrm{or}~\exists
          \Config{\Names'}{\Store}{\Procs'}~\textrm{s.t.}~\Config{\Names}{\Store}{\Procs}->\Config{\Names'}{\Store}{\Procs'}}{By
          i.h.}
        \Pf{}{}{\textbf{Subcase}~\exists
          \Config{\Names'}{\Store}{p:e'}~\textrm{s.t.}~\Config{\Names}{\Store}{p:e}->\Config{\Names'}{\Store}{p:e'}}{}
        \Pf{}{}{\quad e -> e'}{Above}
        \Pf{}{}{\quad\Config{\Names}{\Store}{\Procs,p:E[e]} ->
          \Config{\Names'}{\Store}{\Procs,p:E[e']}}{By rule local}

\Pf{}{}{\textbf{Subcase}~\exists\Config{\Names'}{\Store}{\Procs'}~\textrm{s.t.}~\Config{\Names}{\Store}{\Procs}->\Config{\Names'}{\Store}{\Procs'}}{}
        \Pf{}{}{\quad\Config{\Names}{\Store}{\Procs,p:e} ->
          \Config{\Names'}{\Store}{\Procs',p:e}}{By rule par}
        \Pf{}{}{\textbf{Subcase}~\JCterm{\Config{\Names}{\Store}{p:e}}~\textrm{and}~\JCterm{\Config{\Names}{\Store}{\Procs}}}{}
        \Pf{}{}{\quad\Names_1 = \textrm{RdChans}(\Procs,p:e)~\textrm{and}~\Names_2 = \textrm{WrChans}(\Procs,p:e)}{Suppose}
        \Pf{}{}{\quad\{ (c_1,c_2) \mid c_1 \in \Names_1,
          c_2 \in \Names_2, c_2 \leadsto c_1\} =
          \varnothing~\textrm{or}}{}
        \Pf{}{}{\qquad\{ (c_1,c_2) \mid c_1 \in \Names_1,
          c_2 \in \Names_2, c_2 \leadsto c_1\} \neq
          \varnothing}{}
        \Pf{}{}{\quad\textbf{Subsubcase}~\{ (c_1,c_2) \mid c_1 \in \Names_1,
          c_2 \in \Names_2, c_2 \leadsto c_1\} =
          \varnothing}{}
        \Pf{}{}{\qquad\JCterm{\Config{\Names}{\Store}{\Procs,p:e}}}{By rule Cterm}
        \Pf{}{}{\quad\textbf{Subsubcase}~\{ (c_1,c_2) \mid c_1 \in \Names_1,
          c_2 \in \Names_2, c_2 \leadsto c_1\} \neq
          \varnothing}{}
        \Pf{}{}{\qquad \exists~c_2 \leadsto c_1~\textrm{s.t.}~c_1 \in \Sigma_1,
          c_2 \in \Sigma_2}{Above}
        \Pf{}{}{\qquad\Config{\Names}{\Store}{\Procs, \ProcNm{p} E[R[
                \eLetRd{\eChan{c_1}}{x}{e}] ]} --->
          \Config{\Names}{\Store}{\Procs, \ProcNm{p} E[
              [\ePair{!v}{\eChan{c_1}}{1}/x]e]}~\textrm{or}}{}
        \Pf{}{}{\qquad\quad\Config{\Names}{\Store}{\Procs, \ProcNm{p} E[
              \eWr{\eChan{c_2}}{v}]} --->
          \Config{\Names}{\Store}{\Procs, \ProcNm{p} E[ \eUnit ]}}{By rule rw}
      \end{llproof}
    \end{itemize}    
\end{proof}  
\end{theorem}

\subsection{Preservation}

Preservation for the functional fragment of ILC (local preservation) is also
fairly standard.

\begin{theorem}[Local Preservation]
  If $\Delta; \Gamma|- e : U$ and $e -> e'$, then $\Delta; \Gamma|- e' : U$.
  \begin{proof}
    By structural induction on the derivation of $e -> e'$.
  \end{proof}
\end{theorem}

First, Lemma~\ref{lem:equiv} shows that typing of configurations is preserved
under configuration equivalence.

\begin{lemma}[Preservation Modulo Equivalence]\label{lem:equiv}
  If $\ChTy |- C : \PrTy$ and $C \equiv C'$, then $\ChTy |- C' : \PrTy$.
  \begin{proof}
    By structural induction on $\ChTy |- C : \PrTy$.
  \end{proof}
\end{lemma}

Lemma~\ref{lem:subterms} shows that a subterm of a well-typed evaluation context
is typeable with a subset of the type contexts. Lemma~\ref{lem:replacement}
shows that the subterm of a well-typed evaluation context can be replaced. Both
of these lemmas follow the formulation of Gay and
Vasconcelos~\cite{gay2010linear}.

\begin{lemma}[Typability of Subterms]\label{lem:subterms}
  If $\mathcal{D}$ is a derivation of $\Delta; \Gamma |- E[e] : U$, then there exists $\Delta_1, \Delta_2,
  \Gamma_1,\Gamma_2$ and $V$ such that $\Delta = \Delta_1,\Delta_2$, $\Gamma = \Gamma_1,\Gamma_2$, $\mathcal{D}$ has a
  subderivation $\mathcal{D}'$ concluding $\Delta_1;\Gamma_1 |- e : V$, and the position of $\mathcal{D}'$ in
  $\mathcal{D}$ corresponds to the position of the hole in $E$.
  \begin{proof}
    By structural induction on the structure of $E$.
  \end{proof}
\end{lemma}

\begin{lemma}[Replacement (Evaluation Contexts)]\label{lem:replacement}
  If
  \begin{enumerate}
  \item $\mathcal{D}$ is a derivation of $\Delta_1,\Delta_2;\Gamma_1,\Gamma_2 |- E[e] : U$,
  \item $\mathcal{D}'$ is a subderivation of $\mathcal{D}$ concluding $\Delta_2;
    \Gamma_2 |- e : V$,
  \item the position of $\mathcal{D}'$ in $\mathcal{D}$ corresponds to the
    position of the hole in $E$,
  \item $\Delta_3;\Gamma_3 |- e' : V$,
  \item $\Delta_1,\Delta_3;\Gamma_1,\Gamma_3$ is defined,
  \end{enumerate}
  then $\Delta_1,\Delta_3;\Gamma_1,\Gamma_3 |- E[e'] : U$.
  \begin{proof}
    By structural induction on the structure of $E$.
  \end{proof}  
\end{lemma}

Finally, Lemmas~\ref{lem:sub-int} and~\ref{lem:sub-aff} show that typing of
terms is preserved by substitution.

\begin{lemma}[Substitution (Intuitionistic)]\label{lem:sub-int}
  If
  \begin{enumerate}
  \item $\Delta_1; \Gamma_1, x : A |- e : U$,
  \item $\Delta_2; \Gamma_2 |- e' : A$,
  \item $\Delta_1,\Delta_2 ; \Gamma_1,\Gamma_2$ is defined,
  \end{enumerate}
  then $\Delta_1,\Delta_2; \Gamma_1,\Gamma_2 |- [e'/x]e : U$.
  \begin{proof}
    By structural induction on the derivation of $\Delta_1; \Gamma_1, x : A |- e : U$.
  \end{proof}
\end{lemma}

\begin{lemma}[Substitution (Affine)]\label{lem:sub-aff}
  If
  \begin{enumerate}
  \item $\Delta_1, x : X; \Gamma_1 |- e : U$,
  \item $\Delta_2; \Gamma_2 |- e' : X$,
  \item $\Delta_1,\Delta_2 ; \Gamma_1,\Gamma_2$ is defined,
  \end{enumerate}
  then $\Delta_1,\Delta_2; \Gamma_1,\Gamma_2 |- [e'/x]e : U$.
  \begin{proof}
    By structural induction on the derivation of $\Delta_1, x : X; \Gamma_1 |- e : U$.
  \end{proof}
\end{lemma}

\begin{theorem}[Preservation]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$ and $\JCred{C}{C'}$, then there exists
$\ChTy' \supseteq \ChTy$ and $\PrTy' \supseteq \PrTy$ such that
$\JCty{\StTy'}{\ChTy'}{C'}{\PrTy'}$.
\begin{proof}
    By structural induction on the derivation of $\JCred{C}{C'}$.
  \begin{itemize}[leftmargin=*]
  \item[] \textbf{Case}
    \begin{mathpar}
      \Infer{local}{e_1 ---> e_2 }
      { \Config{\Names}{\Store_1}{\Procs, \ProcNm{p} \proc{E[e_1]}} --->
        \Config{\Names}{\Store_2}{\Procs, \ProcNm{p} \proc{E[e_2]}} }
    \end{mathpar}
    \begin{llproof}
      \Pf{\ChTy}{|-}{\Config{\Names}{\Store_1}{\Procs, \ProcNm{p} \proc{E[e_1]}}
        : \PrTy~\textrm{s.t.}~\PrTy_{\pi} = \{ \PrTy(x) \mid x:e \in \pi\},~U_{p} =
        \PrTy(p)}{Assumption}
      
      \Pf{}{}{\mathcal{D}~\textrm{is a derivation of}~\Delta_1,\Delta_2;\Gamma_1,\Gamma_2|-
        E[e_1] : U_p,}{}
      \Pf{}{}{\quad\mathcal{D}'~\textrm{is a subderivation
          of}~\mathcal{D}~\textrm{concluding}~\Delta_2;\Gamma_2|- e_1 : U,}{}
      \Pf{}{}{\quad\textrm{the position of}~\mathcal{D}'~\textrm{corresponds to
          position of}~\mathcal{D}~\textrm{in}~E}{Assumption}      

      \Pf{\Delta_2; \Gamma_2}{|-}{e_2 : U}{By i.h.}

      \Pf{\Delta_1,\Delta_2; \Gamma_1,\Gamma_2}{|-}{E[e_2] : U_p}{By Lemma~\ref{lem:replacement}
        (Replacement)}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs} : \PrTy_{\pi}}{Above}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\ProcNm{p} \proc{E[e_2]}} : U_p}{Above}

      \Pf{\ChTy' = \ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p} E[e_2]} : \PrTy_{\pi},
        p : U_p = \PrTy = \PrTy'}{By rule cons}
    \end{llproof}

  \item[] \textbf{Case}
    \begin{mathpar}
      \Infer{fork}{ q \notin \Names }
      { \Config{\Names}{\Store}{\Procs, \ProcNm{p} \proc{E[ \eFork{e_1}{e_2} }] } --->
        \Config{\Names,q}{\Store}{\Procs, \ProcNm{q} \proc{e_1}, \ProcNm{p} \proc{E[ e_2 ]}}}      
    \end{mathpar}
    \begin{llproof}
      \Pf{\ChTy}{|-}{\Config{\Names}{\Store_1}{\Procs, \ProcNm{p} \proc{E[\eFork{e_1}{e_2}]}}
        : \PrTy~\textrm{s.t.}~\PrTy_{\pi} = \{ \PrTy(x) \mid x:e \in \pi\},~U_{p} =
        \PrTy(p)}{Assumption}
      
      \Pf{}{}{\mathcal{D}~\textrm{is a derivation of}~\Delta_1,\Delta_2;\Gamma_1,\Gamma_2|-
        E[\eFork{e_1}{e_2}] : U_p,}{}
      \Pf{}{}{\quad\mathcal{D}'~\textrm{is a subderivation
          of}~\mathcal{D}~\textrm{concluding}~\Delta_2;\Gamma_2|- \eFork{e_1}{e_2} : U,}{}
      \Pf{}{}{\quad\textrm{the position of}~\mathcal{D}'~\textrm{corresponds to
          position of}~\mathcal{D}~\textrm{in}~E}{Assumption}

      \Pf{\Delta_2; \Gamma_2}{|-}{e_2 : U}{By inversion (fork)}

      \Pf{\Delta_1,\Delta_2; \Gamma_1,\Gamma_2}{|-}{E[e_2] : U_p}{By Lemma~\ref{lem:replacement}
        (Replacement)}

      \Pf{\Delta_2; \Gamma_2}{|-}{e_1 : U_q}{By inversion (fork)}

      \Pf{\ChTy}{|-}{\Config{\Names,q}{\Store}{\Procs} : \PrTy_{\pi}}{Above}

      \Pf{\ChTy}{|-}{\Config{\Names,q}{\Store}{\ProcNm{p} \proc{E[e_2]}} :
        U_p}{Above}

      \Pf{\ChTy}{|-}{\Config{\Names,q}{\Store}{\Procs, \ProcNm{q} \proc{e_1}} : \PrTy_{\pi},
        q : U_q}{By rule cons}

      \Pf{\ChTy' = \ChTy}{|-}{\Config{\Names,q}{\Store}{\Procs, \ProcNm{q}
          \proc{e_1}}, \ProcNm{p} \proc{E[e_2]} : \PrTy_{\pi}, q : U_q, p : U_p =
        \PrTy, p : U_p = \PrTy'}{By rule cons}
    \end{llproof}

  \item[] \textbf{Case}
    \begin{mathpar}
      \Infer{par}{
      \Config{\Names}{\Store}{\Procs_2} -> \Config{\Names}{\Store}{\Procs_2'}}
      {\Config{\Names}{\Store}{\Procs_1, \Procs_2} ->
       \Config{\Names}{\Store}{\Procs_1,\Procs_2'}}
    \end{mathpar}
    \begin{llproof}
      \Pf{\ChTy}{|-}{\Config{\Names}{\Store_1}{\Procs_1, \Procs_2} :
        \PrTy~\textrm{s.t.}~\PrTy_{\Procs_1} = \{ \PrTy(x) \mid x:e \in
        \Procs_1\},~\PrTy_{\Procs_2} = \{ \PrTy(x) \mid x:e \in
        \Procs_2\}}{Assumption}

      \Pf{\ChTy'\supseteq\ChTy}{|-}{\Config{\Names}{\Store_1}{\Procs_2'} :
        \PrTy_{\Procs_2'}\supseteq\PrTy_{\Procs_2}}{By i.h.}
      \Pf{}{}{}{\todo{}}
    \end{llproof}

  \item[] \textbf{Case}
    \begin{mathpar}
      \Infer{congr}{
      C_1 \equiv C_1' 
      \\
      C_1' ---> C_2'
      \\
      C_2' \equiv C_2
      }
      { C_1 ---> C_2 }
    \end{mathpar}
    \begin{llproof}
      \Pf{\ChTy}{|-}{C_1 : \PrTy}{Assumption}
      \Pf{}{}{C_1 \equiv C_1'}{Given}
      \Pf{\ChTy}{|-}{C_1' : \PrTy}{By Lemma~\ref{lem:equiv}}
      \Pf{\ChTy'\supseteq\ChTy}{|-}{C_2' : \PrTy'\supseteq\PrTy}{By i.h.}
      \Pf{\ChTy'}{|-}{C_2 : \PrTy'}{By Lemma~\ref{lem:equiv}}
    \end{llproof}

  \item[] \textbf{Case}
    \begin{mathpar}
      \Infer{nu}{ c_1, c_2 \notin \Names }
      { \Config{\Names}{\Store}{\Procs, \ProcNm{p} \proc{E[ \eNu{(x_1, x_2)}{e} ]}} --->
        \Config{\Names, c_1, c_2}{\Store}{\Procs, \ProcNm{p} \proc{E[ [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}}}
    \end{mathpar}
    \begin{llproof}
      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p} \proc{E[ \eNu{(x_1, x_2)}{e} ]}}
        : \PrTy~\textrm{s.t.}~\PrTy_{\pi} = \{ \PrTy(x) \mid x:e \in \pi\},~U_{p} =
        \PrTy(p)}{Assumption}
      
      \Pf{}{}{\mathcal{D}~\textrm{is a derivation of}~\Delta_1,\Delta_2;\Gamma_1,\Gamma_2|-
        E[ \eNu{(x_1, x_2)}{e} ] : U_p,}{}
      \Pf{}{}{\quad\mathcal{D}'~\textrm{is a subderivation
          of}~\mathcal{D}~\textrm{concluding}~\Delta_2;\Gamma_2|- \eNu{(x_1, x_2)}{e} : U,}{}
      \Pf{}{}{\quad\textrm{the position of}~\mathcal{D}'~\textrm{corresponds to
          position of}~\mathcal{D}~\textrm{in}~E}{Assumption}

      \Pf{}{}{c_2 \leadsto c_1~\text{s.t.}~\ChTy(c_2) =
        \tyWr{S}~\textrm{and}~\ChTy(c_1) = \tyRd{S}}{Given}      

      \Pf{\Delta_2, x_1: \tyRd{S} ; \Gamma_2, x_2 : \tyWr{S}}{|-}{e : U}{By inversion
        (nu)}

      \Pf{\emptyctxt;\emptyctxt}{|-}{c_1 : \tyRd{S}}{Above}            

      \Pf{\emptyctxt;\emptyctxt}{|-}{c_2 : \tyWr{S}}{Above}

      \Pf{\Delta_2, x_1: \tyRd{S} ; \Gamma_2, x_2 : \tyWr{S}}{|-}{e : U}{By inversion
        (nu)}      

      \Pf{\Delta_2; \Gamma_2}{|-}{e : \proc{E[ [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}}{By
        Lemmas~\ref{lem:sub-int} and~\ref{lem:sub-aff}}
      \Pf{}{}{}{\quad(Substitution)}

      \Pf{\Delta_1,\Delta_2; \Gamma_1,\Gamma_2}{|-}{\proc{E[ [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}
        : U_p}{By Lemma~\ref{lem:replacement}}
      \Pf{}{}{}{\quad(Replacement)}      

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs} : \PrTy_{\pi}}{Above}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\ProcNm{p} \proc{E[
              [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}} : U_p}{Above}

      \Pf{\ChTy' = \ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p}
          \proc{E[ [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}} : \PrTy_{\pi}, p : U_p
        = \PrTy = \PrTy'}{By rule cons}
    \end{llproof}    
    
  \item[] \textbf{Case}
    \begin{mathpar}
    \Infer{rw}
    { c_2 \leadsto c_1 }
    { \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[ \eLetRd{\eChan{c_1}}{x}{e}] ], \ProcNm{q} E_2[ \eWr{\eChan{c_2}}{v}]} --->
      \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ [\ePair{!v}{\eChan{c_1}}{1}/x]e], \ProcNm{q}
        E_2[ \eUnit ]} }
    \end{mathpar}
    \begin{llproof}
      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[
              \eLetRd{\eChan{c_1}}{x}{e}] ], \ProcNm{q} E_2[
            \eWr{\eChan{c_2}}{v}]} : \PrTy~\textrm{s.t.}}{}
      \Pf{}{}{\quad\{ \PrTy(x) \mid x:e \in \pi\} = \PrTy_{\pi},~\PrTy(p) =
        U_{p},~\PrTy(q) = U_{q}}{Assumption}
      
%      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[
%              \eLetRd{\eChan{c_1}}{x}{e}] ], \ProcNm{q} E_2[
%            \eWr{\eChan{c_2}}{v}]} : \PrTy}{Assumption}
      
      \Pf{}{}{\mathcal{D}_p~\textrm{is a derivation of}~\Delta_1,\Delta_1';\Gamma_1,\Gamma_1'|-
        E_1[R[ \eLetRd{\eChan{c_1}}{x}{e}] ] : U_p,}{}
      \Pf{}{}{\quad\mathcal{D}_p'~\textrm{is a subderivation
          of}~\mathcal{D}_p~\textrm{concluding}~\Delta_1';\Gamma_1'|-
        \eLetRd{\eChan{c_1}}{x}{e} : U_p',}{}
      \Pf{}{}{\quad\textrm{the position of}~\mathcal{D}_p'~\textrm{corresponds to
          position of}~\mathcal{D}_p~\textrm{in}~E_1}{Assumption}

      \Pf{}{}{\mathcal{D}_q~\textrm{is a derivation of}~\Delta_2,\Delta_2';\Gamma_2,\Gamma_2'|-
        E_2[\eWr{\eChan{c_2}}{v}] : U_q,}{}
      \Pf{}{}{\quad\mathcal{D}_q'~\textrm{is a subderivation
          of}~\mathcal{D}_q~\textrm{concluding}~\Delta_2';\Gamma_2'|-
        \eWr{\eChan{c_2}}{v} : U_q',}{}
      \Pf{}{}{\quad\textrm{the position of}~\mathcal{D}_q'~\textrm{corresponds to
          position of}~\mathcal{D}_q~\textrm{in}~E_2}{Assumption}

      \Pf{}{}{c_2 \leadsto c_1~\text{s.t.}~\ChTy(c_2) =
        \tyWr{S}~\textrm{and}~\ChTy(c_1) = \tyRd{S}}{Given}

      \Pf{\Delta_1';\Gamma_1',x : \tyTensor{\tyBang{S}}{\tyRd{S}}}{|-}{e : U_p'}{By
        inversion (rd)}

      \Pf{\emptyctxt;\emptyctxt}{|-}{v : S}{By inversion (wr)}

      \Pf{\emptyctxt,\emptyctxt}{|-}{\eBang{v} : \tyBang{S}}{By rule bang}

      \Pf{\emptyctxt,\emptyctxt}{|-}{\ePair{!v}{\eChan{c_1}}{1} :
        \tyTensor{\tyBang{S}}{\tyRd{S}}}{By rule apair}

      \Pf{\Delta_1';\Gamma_1'}{|-}{\ePair{!v}{\eChan{c_1}}{1}/x]e : U_p'}{By
          Lemma~\ref{lem:sub-aff} (Substitution)}

      \Pf{\Delta_1,\Delta_1';\Gamma_1,\Gamma_1'}{|-}{E_1[ [\ePair{!v}{\eChan{c_1}}{1}/x]e] : U_p}{By
        Lemma~\ref{lem:replacement} (Replacement)}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs} : \PrTy_{\pi}}{Above}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\ProcNm{p} E_1[
            [\ePair{!v}{\eChan{c_1}}{1}/x]e]} : p : U_p}{Above}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[
            [\ePair{!v}{\eChan{c_1}}{1}/x]e]} : \PrTy_{\pi}, p : U_p}{By rule cons}

      \Pf{\Delta_2';\Gamma_2'}{|-}{\eUnit : \tyUnit }{By inversion (unit)}

      \Pf{\Delta_2,\Delta_2';\Gamma_2,\Gamma_2'}{|-}{E_2[ \eUnit ] : U_q}{By
        Lemma~\ref{lem:replacement} (Replacement)}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\ProcNm{p} E_1[
            [\ePair{!v}{\eChan{c_1}}{1}/x]e]} : \PrTy_{\pi}, p : U_p}{Above}

      \Pf{\ChTy}{|-}{\Config{\Names}{\Store}{\ProcNm{q} E_2[ \eUnit ]} : q :
        U_q}{Above}
      
      \Pf{\ChTy' = \ChTy}{|-}{\Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ [\ePair{!v}{\eChan{c_1}}{1}/x]e], \ProcNm{q}
        E_2[ \eUnit ]} : \PrTy_{\pi}, U_p, U_q = \PrTy = \PrTy'}{By rule cons}
    \end{llproof}
  \end{itemize}

\end{proof}
\end{theorem}


\section{Confluence}

The following lemmas state structural
invariants over write effects and read channels of a well-typed
configuration: no two writes are in parallel composition, and every read channel end is a non-duplicable (affine) resource.

\begin{lemma}[Unique writer process]
\label{lem:UniqueWriter}
If $C$ is a well-typed configuration with process pool~$\pi$, 
then there exists at most one write-mode process in $\pi$.
\begin{proof}
By structural induction over the typing derivation for $C$.
\end{proof}
\end{lemma}

\begin{lemma}[Unique reader process]
\label{lem:UniqueReader}
If $C$ is a well-typed configuration with process pool~$\pi$, 
and $c$ is a read channel in this configuration,
then there exists at most one process in $\pi$ where $c$ appears.
\begin{proof}
By structural induction over the typing derivation for $C$.
\end{proof}
\end{lemma}

\begin{theorem}[Single-step confluence]
For all well-typed configurations $C$,
%
 if $\JCred{C}{C_1}$ 
and $\JCred{C}{C_2}$ 
then 
there exists renaming function~$f$ 
such that either:
\begin{enumerate}
\item %$\JCterm{C_1}$ and 
$C_1 = f(C_2)$,
or
\item $\exists C_3$ such that $\JCred{C_1}{C_3}$ and $\JCred{f(C_2)}{C_3}$.
\end{enumerate}
\begin{proof}
   By induction on the pair of steps 
   $\left< \JCred{C}{C_1}\right.$, 
   $\left.\JCred{C}{C_2} \right>$.

   We consider the following cases:

   \emph{Case: congruence:} if either step uses \Rule{congr}, we apply the inductive hypothesis.
   
   \emph{Case: independent processes:} 
     the two steps advance distinct processes, using any of the rules \Rule{local}, \Rule{fork} and \Rule{nu},
     we produce $C_3$ by combining those two (independent) steps.     

   \emph{Case: one process:}    
   the two steps advance the same process, we show that this was
   determinisitic (up to naming) by constructing the naming function
   $f$ such that $C_2 = f(C_1)$.  Most cases are straightforward since
   they perform no non-determinisitic choices.  The only source of
   non-determinism is the name choices, in rules \Rule{nu},
   \Rule{fork}, and \Rule{new}; in each case, we map the name choice
   from the second step to that of the first step.

   \emph{Case: read-write interaction:}
   In the case that either step uses \Rule{rw}, 
   we rely on
   lemmas \ref{lem:UniqueWriter} and \ref{lem:UniqueReader}.
   to show that both steps use \Rule{rw},
   and that the reader-writer process pair is unique.
   
\end{proof}
\end{theorem}

By composing multiple uses of this theorem
we prove multi-step confluence.
However, to carry forth this composition, we need a more general
notion of single-step confluence, which is parameteric in a renaming
function for the initial configurations.

\begin{theorem}[Single-step confluence, generalized]
For all well-typed configurations $C$ 
and renaming functions $f$,
%
 if $\JCred{C}{C_1}$ 
and $\JCred{f(C)}{C_2}$ 
then 
there exists renaming function~$g$ 
such that either:
\begin{enumerate}
\item %$\JCterm{C_1}$ and 
$C_1 = g(C_2)$,
or
\item $\exists C_3$ such that $\JCred{C_1}{C_3}$ and $\JCred{g(C_2)}{C_3}$.
\end{enumerate}
\begin{proof}
  (Analogous to first single-step confluence proof.)
\end{proof}
\end{theorem}

We prove a full confluence theorem that is generalized similarly, by
accepting a renaming function~$f$ to produce a new one~$g$:

\begin{theorem}[Full confluence]
For all well-typed configurations $C$,
and renaming functions $f$,
%
 if $\JCredm{C}{C_1}$ 
and $\JCredm{f(C)}{C_2}$ 
and $\JCterm{C_1}$
and $\JCterm{C_2}$
then 
there exists renaming function~$g$ 
such that $C_1 = g(C_2)$.
\begin{proof}
  By induction on the reduction sequence pair
  $\left< \JCredm{C}{C_1}\right.$, 
  $\left.\JCredm{f(C)}{C_2} \right>$.
  Because of single-step confluence, we know that if
  if either reduction sequence is empty, then the other must be empty,
  and that
  if either takes a step, the other must take a step.
  
  \emph{Empty case:}
  When empty, we have the resulting renaming function~$g$ via single-step confluence.

  \emph{Step case:}
  We consider the case where each reduction consists of at least one step:
  $\JCred{C}{C_1'}$ and $\JCredm{C_1'}{C_1}$ and
  $\JCred{f(C)}{C_2'}$ and $\JCredm{C_2'}{C_2}$.
  By single-step confluence, we have that there exists $g_0$ such that $g_0(C_2') = C_1'$.
  By the inductive hypothesis, we have that there exists $g$ such that $C_1 = g(C_2)$.  
\end{proof}
\end{theorem}
