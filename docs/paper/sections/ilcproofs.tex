\section{ILC meta theory}
\label{sec:ilcproofs}

\subsection{Additional syntax}

We define syntax for store, process and channel typings, which each
map a kind of identifier (location, process name, or channel name) to its associated type:

\begin{grammar}
  Store typings
    %(maps process names to their types)
    & $\StTy$
    &$\bnfas$& $\emptyctxt \bnfalt \StTy,\ell:A$
    \\
    Process pool typings
    %(maps process names to their types)
    & $\PrTy$
    &$\bnfas$& $\emptyctxt \bnfalt \PrTy,p:A \bnfalt \PrTy,p:X$
    \\
    Channel pool typings
    %(maps channel names to their types)
    & $\ChTy$
    &$\bnfas$& $\emptyctxt \bnfalt \ChTy,c:A \bnfalt \ChTy,c:X$
\end{grammar}

\subsection{Configuration typings}

Using the syntax above, we define configuration typing as a straightforward extension
of single-process typing, given in \Secref{subsec:types}:

\judgbox{\JCty{\StTy}{\ChTy}{C}{\PrTy} |> m}{Configuration $C$ is well-typed}
\begin{mathpar}
\Infer{empty}
{ 
  \StTy ; \ChTy |- \Store : \StTy
}
{\JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\emptyProcs}}{\cdot} |> \Vm}
\and
\Infer{aff}
{ \StTy ; \ChTy |- e : X |> m_1
  \\
 \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs}}{\PrTy} |> m_2
 \\
 m_1 || m_2 => m_3
}
{ \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs,p:e}}{\PrTy,p:X} |> m_3}
\and
\Infer{int}
{ \StTy ; \ChTy |- e : A |> m_1
  \\
 \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs}}{\PrTy} |> m_2
 \\
 m_1 || m_2 => m_3
}
{ \JCty{\StTy}{\ChTy}{\Config{\Names}{\Store}{\Procs,p:e}}{\PrTy,p:A} |> m_3 }
\end{mathpar}

Notably, parallel procesess with modes $m_1$ and $m_2$ must have modes
that compose, where $m_1 || m_2$ is defined; this invariant ensures that there
is at most one write mode process in a well-typed pool.

Because of the premise in the base case rule (\Rule{empty}), all
well-typed configurations consist of well-typed stores.
%
We define store typing in the standard way:

\judgbox{\StTy ; \ChTy |- \Store : \StTy }
{Under $\StTy$ and $\ChTy$, store~$\Store$ is well-typed}
\begin{mathpar}
\Infer{empty}
{ ~ }
{ 
  \StTy ; \ChTy |- \cdot : \cdot
}
\and
\Infer{loc}
{ \StTy ; \ChTy |- v : A 
  \\
  \StTy ; \ChTy |- \Store : \StTy
}
{ 
  \StTy ; \ChTy |- (\Store, \ell:v) : (\StTy, \ell:A)
}
\end{mathpar}

\subsection{Type soundness}

\begin{lemma}[Non-progress]
For all configurations $C$,
store typings~$\StTy$,
channel typings~$\ChTy$,
and process typings~$\PrTy$,
%
if $\JCty{\StTy}{\ChTy}{C}{\PrTy}$
and $\JCterm{C}$,
then $\not\exists C'$ such that $\JCred{C}{C'}$.
%\begin{proof}
%  TODO
%\end{proof}
\end{lemma}


\begin{theorem}[Progress]
For all configurations $C$,
store typings~$\StTy$,
channel typings~$\ChTy$,
and process typings~$\PrTy$,
%
if $\JCty{\StTy}{\ChTy}{C}{\PrTy} |> m$
then 
either $\JCterm{C}$,
or $\exists C'$ such that $\JCred{C}{C'}$.
%\begin{proof}
%   TODO
%\end{proof}
\end{theorem}

\begin{theorem}[Preservation]
For all configurations $C, C'$,
store typings~$\StTy$,
channel typings~$\ChTy$
and process typings~$\PrTy$,
\\
%
 if $\JCty{\StTy}{\ChTy}{C}{\PrTy} |> m$
and $\JCred{C}{C'}$ 
then there exists 
store typing extension $\StTy' \supseteq \StTy$
channel typing extension $\ChTy' \supseteq \ChTy$
and process typing extension $\PrTy' \supseteq \PrTy$
such that $\JCty{\StTy'}{\ChTy'}{C'}{\PrTy'} |> m'$.
%\begin{proof}
%  TODO
%\end{proof}
\end{theorem}


\subsection{Confluence}

The following lemmas state structural
invariants over write effects and read channels of a well-typed
configuration: no two writes are in parallel composition, and every read channel end is a non-duplicable (affine) resource.

\begin{lemma}[Unique writer process]
\label{lem:UniqueWriter}
If $C$ is a well-typed configuration with process pool~$\pi$, 
then there exists at most one write-mode process in $\pi$.
\begin{proof}
By structural induction over the typing derivation for $C$.
\end{proof}
\end{lemma}

\begin{lemma}[Unique reader process]
\label{lem:UniqueReader}
If $C$ is a well-typed configuration with process pool~$\pi$, 
and $c$ is a read channel in this configuration,
then there exists at most one process in $\pi$ where $c$ appears.
\begin{proof}
By structural induction over the typing derivation for $C$.
\end{proof}
\end{lemma}

\begin{theorem}[Single-step confluence]
For all well-typed configurations $C$,
%
 if $\JCred{C}{C_1}$ 
and $\JCred{C}{C_2}$ 
then 
there exists renaming function~$f$ 
such that either:
\begin{enumerate}
\item %$\JCterm{C_1}$ and 
$C_1 = f(C_2)$,
or
\item $\exists C_3$ such that $\JCred{C_1}{C_3}$ and $\JCred{f(C_2)}{C_3}$.
\end{enumerate}
\begin{proof}
   By induction on the pair of steps 
   $\left< \JCred{C}{C_1}\right.$, 
   $\left.\JCred{C}{C_2} \right>$.

   We consider the following cases:

   \emph{Case: congruence:} if either step uses \Rule{congr}, we apply the inductive hypothesis.
   
   \emph{Case: independent processes:} 
     the two steps advance distinct processes, using any of the rules \Rule{local}, \Rule{fork} and \Rule{nu},
     we produce $C_3$ by combining those two (independent) steps.     

   \emph{Case: one process:}    
   the two steps advance the same process, we show that this was
   determinisitic (up to naming) by constructing the naming function
   $f$ such that $C_2 = f(C_1)$.  Most cases are straightforward since
   they perform no non-determinisitic choices.  The only source of
   non-determinism is the name choices, in rules \Rule{nu},
   \Rule{fork}, and \Rule{new}; in each case, we map the name choice
   from the second step to that of the first step.

   \emph{Case: read-write interaction:}
   In the case that either step uses \Rule{rw}, 
   we rely on
   lemmas \ref{lem:UniqueWriter} and \ref{lem:UniqueReader}.
   to show that both steps use \Rule{rw},
   and that the reader-writer process pair is unique.
   
\end{proof}
\end{theorem}

By composing multiple uses of this theorem
we prove multi-step confluence.
However, to carry forth this composition, we need a more general
notion of single-step confluence, which is parameteric in a renaming
function for the initial configurations.

\begin{theorem}[Single-step confluence, generalized]
For all well-typed configurations $C$ 
and renaming functions $f$,
%
 if $\JCred{C}{C_1}$ 
and $\JCred{f(C)}{C_2}$ 
then 
there exists renaming function~$g$ 
such that either:
\begin{enumerate}
\item %$\JCterm{C_1}$ and 
$C_1 = g(C_2)$,
or
\item $\exists C_3$ such that $\JCred{C_1}{C_3}$ and $\JCred{g(C_2)}{C_3}$.
\end{enumerate}
\begin{proof}
  (Analogous to first single-step confluence proof.)
\end{proof}
\end{theorem}

We prove a full confluence theorem that is generalized similarly, by
accepting a renaming function~$f$ to produce a new one~$g$:

\begin{theorem}[Full confluence]
For all well-typed configurations $C$,
and renaming functions $f$,
%
 if $\JCredm{C}{C_1}$ 
and $\JCredm{f(C)}{C_2}$ 
and $\JCterm{C_1}$
and $\JCterm{C_2}$
then 
there exists renaming function~$g$ 
such that $C_1 = g(C_2)$.
\begin{proof}
  By induction on the reduction sequence pair
  $\left< \JCredm{C}{C_1}\right.$, 
  $\left.\JCredm{f(C)}{C_2} \right>$.
  Because of single-step confluence, we know that if
  if either reduction sequence is empty, then the other must be empty,
  and that
  if either takes a step, the other must take a step.
  
  \emph{Empty case:}
  When empty, we have the resulting renaming function~$g$ via single-step confluence.

  \emph{Step case:}
  We consider the case where each reduction consists of at least one step:
  $\JCred{C}{C_1'}$ and $\JCredm{C_1'}{C_1}$ and
  $\JCred{f(C)}{C_2'}$ and $\JCredm{C_2'}{C_2}$.
  By single-step confluence, we have that there exists $g_0$ such that $g_0(C_2') = C_1'$.
  By the inductive hypothesis, we have that there exists $g$ such that $C_1 = g(C_2)$.  
\end{proof}
\end{theorem}
