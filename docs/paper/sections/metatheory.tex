\section{ILC Metatheory}
\label{sec:metatheory}

%(We summarize the meta theory of ILC; see TODO for full proofs).

Intuitively, ILC's type system design enforces that a
configuration's reduction consists of a unique
(\emph{deterministic}) sequence of reader-writer process pairings,
and is \emph{confluent} with any other reduction choice that exchanges 
the order of \emph{other} (non-interactive) reduction steps.
%among a unique sequence of read-write process pairs.
%
As explained in Section~\ref{sec:ilc}, ILC's type system does so by restricting the
write effects (via an affine write token) and read effects (via affine read
channels) of processes.
%
The proofs of type soundness, whose statements we discuss next, 
establish the validity of these invariants.
%
These language-level invariants support confluence theorems, also
stated below.
%
These theorems include \emph{full confluence}:
Any two full reductions of a configuration yield a pair of equivalent configurations
(isomorphic, up to a renaming of nondeterministic name choices).
%

\subsection{Type Soundness}

We prove type soundness of ILC via mostly-standard notions of progress
and preservation.
%
To state these theorems, we follow the usual recipe, except that we give a
special definition of program termination that permits deadlocks. (Recall that
ILC is concerned with enforcing \emph{confluence} as its central metatheoretic
property, \emph{not} deadlock freedom.)
%
Informally, $\JCterm{C}$ holds when:
\begin{enumerate}[leftmargin=*]
 \item $C$ is fully normal: Every process in~$C$ is normalized (consists of a
   value).
 \item $C$ is (at least partially) deadlocked: Some (possibly empty) portion of
   $C$ is normal, and there exists one or more reading processes in $C$, or
   there exists one or more writing processes in $C$, however, no reader-writer
   process pair exists for a common channel.
\end{enumerate}

%

We also extend the type system given in Section~\ref{subsec:types} with typing
rules for configurations, including typing contexts for channels $\ChTy$ and
process pool typings $\PrTy$. These details, along with the proofs of progress
and preservation, can be found in the Appendix.
%
%We omit these details here for space reasons, 
%and we refer the interested reader to the Appendix.
%
%(TODO: As discussed in ~\Secref{sec:related}, deadlock freedom is an
%orthogonal concern that a future variation of ILC could enforce).

%TODO: define $\JCty{\StTy}{\ChTy}{C}{\PrTy}$
%TODO: define $\ChTy' \supseteq \ChTy$
%TODO: define $\PrTy' \supseteq \PrTy$

%\begin{lemma}[Non-progress]
%For all configurations $C$,
%channel typings~$\ChTy$,
%and process typings~$\PrTy$,
%%
%if $\JCty{\StTy}{\ChTy}{C}{\PrTy}$
%and $\JCterm{C}$,
%then $\not\exists C'$ such that $\JCred{C}{C'}$.
%%% \begin{proof}
%%%   TODO
%%% \end{proof}
%\end{lemma}

\begin{theorem}[Progress]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$, then either $\JCterm{C}$ or there exists
$C'$ such that $\JCred{C}{C'}$.
%\begin{proof}
%    By structural induction on the derivation of
%    $\JCty{\StTy}{\ChTy}{C}{\PrTy}$.
%\end{proof}
\end{theorem}

\begin{theorem}[Preservation]
If $\JCty{\StTy}{\ChTy}{C}{\PrTy}$ and $\JCred{C}{C'}$, then there exists
$\ChTy' \supseteq \ChTy$ and $\PrTy' \supseteq \PrTy$ such that
$\JCty{\StTy'}{\ChTy'}{C'}{\PrTy'}$.
%\begin{proof}
%  By structural induction on the derivation of $\JCred{C}{C'}$.
%\end{proof}
\end{theorem}

\subsection{Confluence}

Confluence implies, among other things, that the order of reduction steps is
inconsequential, and that no process scheduling choices will affect
the final outcome. ILC's type system enforces confluence 
%by enforcing a stronger
%property: the communication effects of every reduction are
%\emph{unique}, 
up to nondeterministic naming choices in 
rules \Rule{nu} and \Rule{fork} (Figure~\ref{fig:semantics}).
%
To account for different choices of dynamically-named channels and processes, respectively, 
we state and prove confluence
with respect to a renaming function~$f$, which consistently renames
these choices in a related configuration:

\begin{theorem}[Single-step confluence]
For all well-typed configurations $C$,
%
 if $\JCred{C}{C_1}$ 
and $\JCred{C}{C_2}$ 
then 
there exists a renaming function~$f$ 
such that either:
\begin{enumerate}
\item %$\JCterm{C_1}$ and 
$C_1 = f(C_2)$,
or
\item there exists $C_3$ such that $\JCred{C_1}{C_3}$ and $\JCred{f(C_2)}{C_3}$.
\end{enumerate}
%\begin{proof}
%   By induction on the pair of steps 
%   $\left< \JCred{C}{C_1}\right.$, 
%   $\left.\JCred{C}{C_2} \right>$.
%\end{proof}
\end{theorem}

Intuitively, the sister configuration $C_2$ is either different
because of a name choice (case 1), or a different process scheduling choice
(case 2).  In either case, there exists a renaming of any choice made
to reach $C_2$, captured by function~$f$.
%
By composing multiple uses of this theorem, and the renaming functions
that they construct, we prove a multi-step notion of confluence that 
reduces a single configuration $C$ to two equivalent terminal configurations,
 $C_1$ and $C_2$:

\begin{theorem}[Full confluence]
For all well-typed configurations $C$,
%
 if $\JCredm{C}{C_1}$ 
and $\JCredm{C}{C_2}$ 
and $\JCterm{C_1}$
and $\JCterm{C_2}$
then 
there exists renaming function~$f$ 
such that $C_1 = f(C_2)$.
%\begin{proof}
%    By induction on the reduction sequence pair
%  $\left< \JCredm{C}{C_1}\right.$, 
%  $\left.\JCredm{f(C)}{C_2} \right>$.
%\end{proof}
\end{theorem}

The proofs of these statements can be found in the Appendix.
