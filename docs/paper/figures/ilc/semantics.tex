\begin{figure*}[t]
\centering
\begin{subfigure}{0.35\textwidth}
\begin{grammar}
  Channel names & $c$   &$\bnfas$& $\cdots$
  \\
  Process names & $p,q$ &$\bnfas$& $\cdots$
  \\
  Name sets
  & $\Names$ 
    & $\bnfas$ & $\emptyNames ~|~ \Names, c ~|~ \Names, p$
  \\
  Process pools
  & $\Procs$ 
    & $\bnfas$ & $\emptyProcs ~|~ \Procs, p{:}\proc{e}$
\end{grammar}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
  \begin{grammar}
  Configurations
  & $C$
     & $\bnfas$ & $\Config{\Names}{}{\Procs} $
     \\
 Evaluation contexts
  & $E$
     & $\bnfas$ & 
 $\bullet \bnfalt \eLet{x}{E}{e} \bnfalt \eApp{E}{e}{\ell} \bnfalt \eApp{v}{E}{\ell}$
\\ &&& $\bnfaltbrk \eSplitt{\ell}{E}{x_1}{x_2}{e} \bnfalt \eCase{\ell}{E}{x_1}{e_1}{x_2}{e_2}$
\\
 Read contexts
  & $R$
%%
%% This initial definition of R is too limiting: It's not general enough to support the progress theorem:
%     & $\bnfas$ & $\bullet \bnfalt \eRd{\eChan{c}} \oplus R \bnfalt R \oplus \eRd{\eChan{c}}$
     & $\bnfas$ & $\bullet \bnfalt e \boxplus R \bnfalt R \boxplus e$
\end{grammar}
\end{subfigure}
\caption{Channel names, process names, configurations, evaluation contexts, and
  read contexts.}
\label{fig:configs}
\end{figure*}

\begin{figure*}
\centering
\judgbox{C_1 \equiv C_2}{~~Configurations~$C_1$ and $C_2$ are equivalent.}
\begin{mathpar}
\Infer{permProcs}
{  \Procs_1 \equiv_\textsf{perm} \Procs_2 }
{ \Config{\Names}{\Store}{\Procs_1} \equiv \Config{\Names}{\Store}{\Procs_2} }
\end{mathpar}
%\caption{Structural congruence.}
%\label{fig:structural-congruence}
%\end{figure*}
%
%\begin{figure*}
\judgbox{C_1 ---> C_2}{~~Configuration~$C_1$ reduces to $C_2$.}
\begin{mathpar}
\Infer{local}{e_1 ---> e_2 }
{ \Config{\Names}{\Store_1}{\Procs, \ProcNm{p} \proc{E[e_1]}} --->
  \Config{\Names}{\Store_2}{\Procs, \ProcNm{p} \proc{E[e_2]}} }
\and
\Infer{fork}{ q \notin \Names }
{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} \proc{E[ \eFork{e_1}{e_2} }] } --->
  \Config{\Names,q}{\Store}{\Procs, \ProcNm{q} \proc{e_1}, \ProcNm{p} \proc{E[ e_2 ]}}}
\and
\Infer{par}{
\Config{\Names}{\Store}{\Procs_1} -> \Config{\Names'}{\Store}{\Procs_1'}}
{\Config{\Names}{\Store}{\Procs_1, \Procs_2} ->
  \Config{\Names'}{\Store}{\Procs_1',\Procs_2}}
%
%\Store}{\Procs_1'}}
%\Config{\Names_1',\Names_2}{\Store}{\Procs_1',\Procs_2}}
\and
\Infer{congr}{
C_1 \equiv C_1' 
\\
C_1' ---> C_2'
\\
C_2' \equiv C_2
}
{ C_1 ---> C_2 }
\and
\Infer{nu}{ c_1, c_2 \notin \Names }
{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} \proc{E[ \eNu{(x_1, x_2)}{e} ]}} --->
  \Config{\Names, c_1, c_2}{\Store}{\Procs, \ProcNm{p} \proc{E[ [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}}}
\and
\Infer{rw}
{ c_2 \leadsto c_1 }
{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[ \eLetRd{\eChan{c_1}}{x}{e}] ], \ProcNm{q} E_2[ \eWr{\eChan{c_2}}{v}]} --->
  \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ [\ePair{!v}{\eChan{c_1}}{1}/x]e], \ProcNm{q}
    E_2[ \eUnit ]} }
%\Infer{rw}
%{ c_2 \leadsto c_1 }
%{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[ \eRd{\eChan{c_1}}] ], \ProcNm{q} E_2[ \eWr{\eChan{c_2}}{v}]} --->
%  \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ \ePair{!v}{\eChan{c_1}}{\wm}], \ProcNm{q}
%    E_2[ \eUnit ]} }
%\Infer{rw}
%{ c_2 \leadsto c_1 }
%{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[ \eRd{\eChan{c_1}}] ], \ProcNm{q} E_2[ \eWr{\eChan{c_2}}{v}]} --->
%  \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ (v, \eChan{c_1})], \ProcNm{q}
%    E_2[ () ]} }
\end{mathpar}

\judgbox{e_1 ---> e_2}{~~Expression~$e_1$ reduces to~$e_2$.}
\begin{mathpar}
\Infer{let}
{}
{ \eLet{x}{v}{e} ---> [v/x]e }
\and
\Infer{app}
{}
{ \eApp{(\eLamm{\ell}{x}{e})}{v}{\ell} ---> [v/x]e }
\and
\Infer{split}
{ }
{ \eSplitt{\ell}{\ePair{v_1}{v_2}{\ell}}{x_1}{x_2}{e} ---> [v_1/x_1][v_2/x_2]e }
\and
\Infer{case}
{ }
{ \eCase{\ell}{\eInjj{\ell}{i}{v}}{x_1}{e_1}{x_2}{e_2} ---> [v/x_i]e_i }
\and
\Infer{fix}
{ }
{ \eFixx{\ell}{x}{e} ---> [\eFixx{\ell}{x}{e} / x] e }
\end{mathpar}
\caption{Reduction semantics.}
\label{fig:semantics}
\end{figure*}
