\begin{figure*}[t]
\centering
\begin{subfigure}{0.35\textwidth}
\begin{grammar}
  Channel names & $c$   &$\bnfas$& $\cdots$
  \\
  Process names & $p,q$ &$\bnfas$& $\cdots$
  \\
  Store locations & $\ell$ & $\bnfas$ & $\cdots$
  \\[1mm]
  Name sets
  & $\Names$ 
    & $\bnfas$ & $\emptyNames ~|~ \Names, c ~|~ \Names, p$
  \\
  Stores & $\Store$ & $\bnfas$ & $\Store ~|~ \Store, \ell{:}v$
  \\
  Process pools
  & $\Procs$ 
    & $\bnfas$ & $\emptyProcs ~|~ \Procs, p{:}\proc{e}$
    \\[1mm]
  Configurations
  & $C$
     & $\bnfas$ & $\Config{\Names}{\Store}{\Procs} $
     \\[1mm]
\end{grammar}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
\begin{grammar}
 Evaluation
  & $E$
     & $\bnfas$ & 
 $\bullet \bnfalt \eLet{x}{E}{e} \bnfalt \eLetBang{x}{E}{e}$
\\ contexts &&& $\bnfaltbrk \eApp{E}{e} \bnfalt \eApp{v}{E} \bnfalt \eRef{E} \bnfalt \eGet{E}$
     \\ &&& $\bnfaltbrk \eSet{E}{e} \bnfalt \eSet{\ell}{E}$
\\ &&& $\bnfaltbrk \eSplit{E}{x_1}{x_2}{e} \bnfalt \eCase{E}{x_1}{e_1}{x_2}{e_2}$
\\[1mm]
 Read contexts
  & $R$
%%
%% This initial definition of R is too limiting: It's not general enough to support the progress theorem:
%     & $\bnfas$ & $\bullet \bnfalt \eRd{\eChan{c}} \oplus R \bnfalt R \oplus \eRd{\eChan{c}}$
     & $\bnfas$ & $\bullet \bnfalt e \oplus R \bnfalt R \oplus e$
\end{grammar}
\end{subfigure}
\caption{Channel names, process names, configurations and evaluation contexts.}
\label{fig:configs}
\end{figure*}

\begin{figure*}
\centering
\judgbox{C_1 \equiv C_2}{~~Configurations~$C_1$ and $C_2$ are equivalent.}
\begin{mathpar}
\Infer{permProcs}
{  \Procs_1 \equiv_\textsf{perm} \Procs_2 }
{ \Config{\Names}{\Store}{\Procs_1} \equiv \Config{\Names}{\Store}{\Procs_2} }
\end{mathpar}
%\caption{Structural congruence.}
%\label{fig:structural-congruence}
%\end{figure*}
%
%\begin{figure*}
\judgbox{C_1 ---> C_2}{~~Configuration~$C_1$ reduces to $C_2$.}
\begin{mathpar}
\Infer{local}{ \Store_1 ; e_1 ---> \Store_2 ; e_2 }
{ \Config{\Names}{\Store_1}{\Procs, \ProcNm{p} \proc{E[e_1]}} --->
  \Config{\Names}{\Store_2}{\Procs, \ProcNm{p} \proc{E[e_2]}} }
\and
\Infer{fork}{ q \notin \Names }
{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} \proc{E[ \eFork{e_1}{e_2} }] } --->
  \Config{\Names,q}{\Store}{\Procs, \ProcNm{q} \proc{e_1}, \ProcNm{p} \proc{E[ e_2 ]}}}
\and
\Infer{congr}{
C_1 \equiv C_1' 
\\
C_1' ---> C_2'
\\
C_2' \equiv C_2
}
{ C_1 ---> C_2 }
\and
\Infer{nu}{ c_1, c_2 \notin \Names }
{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} \proc{E[ \eNu{(x_1, x_2)}{e} ]}} --->
  \Config{\Names, c_1, c_2}{\Store}{\Procs, \ProcNm{p} \proc{E[ [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}}}
\and
\Infer{rw}
{ c_2 \leadsto c_1 }
{ \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[R[ \eRd{\eChan{c_1}}] ], \ProcNm{q} E_2[ \eWr{\eChan{c_2}}{v}]} --->
  \Config{\Names}{\Store}{\Procs, \ProcNm{p} E_1[ (v, \eChan{c_1})], \ProcNm{q} E_2[ () ]} }
\\
\end{mathpar}

\judgbox{\Store_1 ; e_1 ---> \Store_2 ; e_2}{~~Under store $\Store_1$,
  expression~$e_1$ reduces to~$\Store_2 ; e_2$.}
\begin{mathpar}
\Infer{let}
{}
{ \Store ; \eLet{x}{v}{e} ---> \Store ; [v/x]e }
\and
\Infer{let!}
{}
{ \Store ; \eLetBang{x}{v}{e} ---> \Store ; [v/x]e }
\and
\Infer{app}
{}
{ \Store ; \eApp{(\eLam{x}{e})}{v} ---> \Store ; [v/x]e }
\and
\Infer{split}
{ }
{ \Store ; \eSplit{\ePair{v_1}{v_2}{}}{x_1}{x_2}{e} ---> \Store ; [v_1/x_1][v_2/x_2]e }
\and
\Infer{case}
{ }
{ \Store ; \eCase{\eInj{i}{v}}{x_1}{e_1}{x_2}{e_2} ---> \Store ; [v/x_i]e_i }
\and
\Infer{fix}
{ }
{ \Store ; \eFix{x}{e} ---> \Store ; [\eFix{x}{e} / x] e }
~\hspace*{4mm}
\Infer{ref}
{ \ell \not \in dom(\Store) }
{ \Store ; \eRef{v} ---> \Store, \ell{:}v ; \ell }
~\hspace*{4mm}
\Infer{get}
{ \Store(\ell) = v }
{ \Store ; \eGet{\ell} ---> \Store; v }
~\hspace*{4mm}
\Infer{set}
{ }
{ \Store ; \eSet{\ell}{v} ---> \Store\{\ell := v\}; \eUnit }
\end{mathpar}
\caption{Reduction semantics.}
\label{fig:semantics}
\end{figure*}
