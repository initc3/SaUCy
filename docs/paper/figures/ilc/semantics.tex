\begin{figure*}
\centering
\begin{grammar}
  Channels
  & $\Chans$ 
    & $\bnfas$ & $\emptyChans ~|~ \Chans, c$
    \\[2mm]
  Process pool
  & $\Procs$ 
    & $\bnfas$ & $\emptyProcs ~|~ \Procs, \proc{e}$
    \\[2mm]
  Configurations
  & $C$
     & $\bnfas$ & $\Config{\Chans}{\Store}{\Procs} $
     \\[2mm]
 Evaluation contexts
  & $E$
     & $\bnfas$ & $\bullet \bnfalt \eLet{x}{E}{e} \bnfalt \eApp{E}{e} \bnfalt
 \eApp{v}{E} \bnfalt \eRef{E} \bnfalt \eGet{E} \bnfalt \eSet{E}{e}$
     \\ &&& $\bnfaltbrk \eSet{\ell}{E} \bnfalt \eSeq{E}{e} \bnfalt
     \eSplit{E}{x_1}{x_2}{e} \bnfalt \eCase{E}{x_1}{e_1}{x_2}{e_2}$
\\[2mm]
 Read contexts
  & $R$
     & $\bnfas$ & $\bullet \bnfalt \eRd{\eChan{c}} \oplus R \bnfalt R \oplus \eRd{\eChan{c}}$
\end{grammar}
\caption{Configurations and evaluation contexts.}
\label{fig:configs}
\end{figure*}

\begin{figure*}
\centering
\judgbox{C_1 \equiv C_2}{~~Configurations~$C_1$ and $C_2$ are equivalent.}
\begin{mathpar}
\Infer{permProcs}
{  \Procs_1 \equiv_\textsf{perm} \Procs_2 }
{ \Config{\Chans}{\Store}{\Procs_1} \equiv \Config{\Chans}{\Store}{\Procs_2} }
\end{mathpar}
%\caption{Structural congruence.}
%\label{fig:structural-congruence}
%\end{figure*}
%
%\begin{figure*}
\judgbox{C_1 ---> C_2}{~~Configuration~$C_1$ reduces to $C_2$.}
\begin{mathpar}
\Infer{local}{ \Store_1 ; e_1 ---> \Store_2 ; e_2 }
{ \Config{\Chans}{\Store_1}{\Procs, \proc{E[e_1]}} --->
  \Config{\Chans}{\Store_2}{\Procs, \proc{E[e_2]}} }
\and
\Infer{fork}{ ~ }
{ \Config{\Chans}{\Store}{\Procs, \proc{E[ \eFork{e_1}{e_2} }] } --->
  \Config{\Chans}{\Store}{\Procs, \proc{e_1}, \proc{E[ e_2 ]}}}
\and
\Infer{congr}{
C_1 \equiv C_1' 
\\
C_1' ---> C_2'
\\
C_2' \equiv C_2
}
{ C_1 ---> C_2 }
\and
\Infer{nu}{ c_1, c_2 \notin \Chans }
{ \Config{\Chans}{\Store}{\Procs, \proc{E[ \eNu{(x_1, x_2)}{e} ]}} --->
  \Config{\Chans, c_1, c_2}{\Store}{\Procs, \proc{E[ [\eChan{c_1}/x_1][\eChan{c_2}/x_2]e ]}}}
\and
\Infer{rw}
{ c_2 \leadsto c_1 }
{ \Config{\Chans}{\Store}{\Procs, E_1[R[ \eRd{\eChan{c_1}}] ], E_2[ \eWr{\eChan{c_2}}{v}]} --->
  \Config{\Chans}{\Store}{\Procs, E_1[ (v, \eChan{c_1})], E_2[ \e]} }
\\
\end{mathpar}

\judgbox{\Store_1 ; e_1 ---> \Store_2 ; e_2}{~~Under store $\Store_1$,
  expression~$e_1$ reduces to~$\Store_2 ; e_2$.}
\begin{mathpar}
\Infer{let}
{}
{ \Store ; \eLet{x}{v}{e} ---> \Store ; [v/x]e }
\and
\Infer{app}
{}
{ \Store ; \eApp{(\eLam{x}{e})}{v} ---> \Store ; [v/x]e }
\and
\Infer{split}
{ }
{ \Store ; \eSplit{\ePair{v_1}{v_2}}{x_1}{x_2}{e} ---> \Store ; [v_1/x_1][v_2/x_2]e }
\and
\Infer{case}
{ }
{ \Store ; \eCase{\eInj{i}{v}}{x_1}{e_1}{x_2}{e_2} ---> \Store ; [v/x_i]e_i }
\and
\Infer{fix}
{ }
{ \Store ; \eFix{x}{e} -> \Store ; e\ \eFix{x}{e} }
\and
\Infer{seq}
{ }
{ \Store ; (\eSeq{v}{e}) ---> \Store ; e }
\and
\Infer{ref}
{ \ell \not \in dom(\Store) }
{ \Store ; \eRef{v} -> \Store, \ell : v ; \ell }
\and
\Infer{get}
{ \Store(\ell) = v }
{ \Store ; \eGet{\ell} -> \Store; v }
\and
\Infer{set}
{ }
{ \Store ; \eSet{\ell}{v} -> [\ell \mapsto v]\Store; \eUnit }
\end{mathpar}
\caption{Reduction semantics.}
\label{fig:semantics}
\end{figure*}
